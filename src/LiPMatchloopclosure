#include <LiPMatch.h>
#include <pcl/filters/radius_outlier_removal.h>
#include <pcl/filters/statistical_outlier_removal.h>

using namespace std;
using namespace Eigen;
using namespace LiPMatch_ns;


LiPMatch::LiPMatch() : LiPMatch_stop(false), LiPMatch_finished(false)
{
    LiPMatch_hd = createThreadFromObjectMethod(this,&LiPMatch::run);

    keyframe_vec.clear();

    all_kfs_pose.points.clear();

    map_rfn.set_down_sample_resolution( 0.75 );
}


//max_cos_normal=0.9848   // Two planar patches that represent the same surface must have similar normals -> cos(angle) s 1   (10�)
//max_dist_center_plane=0.12  // Two planar patches that represent the same surface must have their center in the same plane
//proximity_threshold=0.15  // Two planar patches that represent the same surface must overlap or be nearby

bool LiPMatch::areSamePlane(Plane &plane1, Plane &plane2, const float &cosAngleThreshold, const float &distThreshold, const float &proxThreshold)
{
    if( plane1.v3normal.dot(plane2.v3normal) < cosAngleThreshold )
        return false;
//    cout << "normal " << plane1.v3normal.dot(plane2.v3normal) << " " << cosAngleThreshold << endl;

    // Check the normal distance of the planes centers using their average normal
    float dist_normal = plane1.v3normal.dot(plane2.v3center - plane1.v3center);

    if(fabs(dist_normal) > distThreshold ) // Avoid matching different parallel planes
        return false;
//    float thres_max_dist = max(distThreshold, distThreshold*2*(plane2.v3center - plane1.v3center).norm());
//    if(fabs(dist_normal) > thres_max_dist ) // Avoid matching different parallel planes
//        return false;

    return arePlanesNearby(plane1, plane2, proxThreshold);
}

template <class POINT>
static Eigen::Vector3f diffPoints(const POINT &P1, const POINT &P2)
{
    Eigen::Vector3f diff;
    diff[0] = P1.x - P2.x;
    diff[1] = P1.y - P2.y;
    diff[2] = P1.z - P2.z;
    return diff;
}

bool LiPMatch::arePlanesNearby(Plane &plane1, Plane &plane2, const float distThreshold)
{
    float distThres2 = distThreshold * distThreshold;

    // First we check distances between centroids and vertex to accelerate this check
    if( (plane1.v3center - plane2.v3center).squaredNorm() < distThres2 )
        return true;

    for(unsigned i=1; i < plane1.polygonContourPtr->size(); i++)
        if( (getVector3fromPointXYZ(plane1.polygonContourPtr->points[i]) - plane2.v3center).squaredNorm() < distThres2 )
            return true;

    for(unsigned j=1; j < plane2.polygonContourPtr->size(); j++)
        if( (plane1.v3center - getVector3fromPointXYZ(plane2.polygonContourPtr->points[j]) ).squaredNorm() < distThres2 )
            return true;

    for(unsigned i=1; i < plane1.polygonContourPtr->size(); i++)
        for(unsigned j=1; j < plane2.polygonContourPtr->size(); j++)
            if( (diffPoints(plane1.polygonContourPtr->points[i], plane2.polygonContourPtr->points[j]) ).squaredNorm() < distThres2 )
                return true;
    return false;
}

//可以增加包含车辆的最小凸包
bool LiPMatch::areSameVehicle(Vehicle &vehicle1, Vehicle &vehicle2, const float &distThreshold)
{
    float distThres2 = distThreshold * distThreshold;

//    std::cout<<(vehicle1.v3center - vehicle2.v3center).squaredNorm()<<"  "<<distThres2<<std::endl;

    if( (vehicle1.v3center - vehicle2.v3center).squaredNorm() < distThres2 )
        return true;

    return false;
}

bool LiPMatch::areSamePole(Pole &pole1, Pole &pole2, const float &distThreshold)
{
    float distThres2 = distThreshold * distThreshold;

    if( (pole1.v3center - pole2.v3center).squaredNorm() < distThres2 )
        return true;
    return false;
}

void LiPMatch::mergePlanes(Plane &updatePlane, Plane &discardPlane)
{
    // Update normal and center
    updatePlane.v3normal = updatePlane.areaVoxels*updatePlane.v3normal + discardPlane.areaVoxels*discardPlane.v3normal;
    updatePlane.v3normal = updatePlane.v3normal / (updatePlane.v3normal).norm();

//    discardPlane.v3normal = updatePlane.v3normal;

//    std::cout<<"updatePlane.d "<<updatePlane.d<<" discardPlane.d "<<discardPlane.d<<std::endl;
    updatePlane.d = updatePlane.areaVoxels*updatePlane.d + discardPlane.areaVoxels*discardPlane.d;
    updatePlane.d = updatePlane.d/(updatePlane.areaVoxels + discardPlane.areaVoxels);
//    discardPlane.d = updatePlane.d;
//    std::cout<<"updatePlane.d "<<updatePlane.d<<std::endl;

    // Update point inliers
//  *updatePlane.polygonContourPtr += *discardPlane.polygonContourPtr; // Merge polygon points
    *updatePlane.planePointCloudPtr += *discardPlane.planePointCloudPtr; // Add the points of the new detection and perform a voxel grid

    // Filter the points of the patch with a voxel-grid. This points are used only for visualization
    static pcl::VoxelGrid<pcl::PointXYZI> merge_grid;
    merge_grid.setLeafSize(0.35,0.35,0.35);
    pcl::PointCloud<pcl::PointXYZI> mergeCloud;
    merge_grid.setInputCloud (updatePlane.planePointCloudPtr);
    merge_grid.filter (mergeCloud);
    updatePlane.planePointCloudPtr->clear();
    *updatePlane.planePointCloudPtr = mergeCloud;

//    *discardPlane.planePointCloudPtr = mergeCloud;

    double planep[4];
    planep[0] = updatePlane.v3normal(0);
    planep[1] = updatePlane.v3normal(1);
    planep[2] = updatePlane.v3normal(2);
    planep[3] = updatePlane.d;

//    *discardPlane.planePointCloudPtr = *updatePlane.planePointCloudPtr;
    updatePlane.calcConvexHull(updatePlane.planePointCloudPtr,planep);
    updatePlane.computeMassCenterAndArea();
    updatePlane.calcElongationAndPpalDir();

    // Move the points to fulfill the plane equation
//    updatePlane.forcePtsLayOnPlane();

    // Update area
    updatePlane.areaVoxels= updatePlane.planePointCloudPtr->size() * 0.0025;

    discardPlane.v3center = updatePlane.v3center;
    discardPlane.v3normal = updatePlane.v3normal;
    discardPlane.d = updatePlane.d;
    discardPlane.elongation = updatePlane.elongation;
    discardPlane.areaVoxels = updatePlane.areaVoxels;
    discardPlane.areaHull = updatePlane.areaHull;
    discardPlane.matched = updatePlane.matched;
    discardPlane.eigenval = updatePlane.eigenval;
    *discardPlane.polygonContourPtr = *updatePlane.polygonContourPtr;
    *discardPlane.planePointCloudPtr = *updatePlane.planePointCloudPtr;
////    discardPlane = updatePlane;
}

void LiPMatch::mergePlanes2(Plane &updatePlane, Plane &discardPlane)
{
    // Update normal and center
    updatePlane.v3normal = updatePlane.areaVoxels*updatePlane.v3normal + discardPlane.areaVoxels*discardPlane.v3normal;
    updatePlane.v3normal = updatePlane.v3normal / (updatePlane.v3normal).norm();

//    discardPlane.v3normal = updatePlane.v3normal;

//    std::cout<<"updatePlane.d "<<updatePlane.d<<" discardPlane.d "<<discardPlane.d<<std::endl;
    updatePlane.d = updatePlane.areaVoxels*updatePlane.d + discardPlane.areaVoxels*discardPlane.d;
    updatePlane.d = updatePlane.d/(updatePlane.areaVoxels + discardPlane.areaVoxels);
//    discardPlane.d = updatePlane.d;
//    std::cout<<"updatePlane.d "<<updatePlane.d<<std::endl;

    // Update point inliers
//  *updatePlane.polygonContourPtr += *discardPlane.polygonContourPtr; // Merge polygon points
    *updatePlane.planePointCloudPtr += *discardPlane.planePointCloudPtr; // Add the points of the new detection and perform a voxel grid

    // Filter the points of the patch with a voxel-grid. This points are used only for visualization
    static pcl::VoxelGrid<pcl::PointXYZI> merge_grid;
    merge_grid.setLeafSize(0.35,0.35,0.35);
    pcl::PointCloud<pcl::PointXYZI> mergeCloud;
    merge_grid.setInputCloud (updatePlane.planePointCloudPtr);
    merge_grid.filter (mergeCloud);
    updatePlane.planePointCloudPtr->clear();
    *updatePlane.planePointCloudPtr = mergeCloud;

//    *discardPlane.planePointCloudPtr = mergeCloud;

    double planep[4];
    planep[0] = updatePlane.v3normal(0);
    planep[1] = updatePlane.v3normal(1);
    planep[2] = updatePlane.v3normal(2);
    planep[3] = updatePlane.d;

//    *discardPlane.planePointCloudPtr = *updatePlane.planePointCloudPtr;
    updatePlane.calcConvexHull(updatePlane.planePointCloudPtr,planep);
    updatePlane.computeMassCenterAndArea();
    updatePlane.calcElongationAndPpalDir();

    // Move the points to fulfill the plane equation
//    updatePlane.forcePtsLayOnPlane();

    // Update area
    updatePlane.areaVoxels= updatePlane.planePointCloudPtr->size() * 0.0025;

}

void LiPMatch::mergeVehicles(Vehicle &updateVehicle, Vehicle &discardVehicle)
{
    *updateVehicle.VehiclePointCloudPtr += *discardVehicle.VehiclePointCloudPtr;

    static pcl::VoxelGrid<pcl::PointXYZI> merge_grid;
    merge_grid.setLeafSize(0.35,0.35,0.35);
    pcl::PointCloud<pcl::PointXYZI> mergeCloud;
    merge_grid.setInputCloud (updateVehicle.VehiclePointCloudPtr);
    merge_grid.filter (mergeCloud);
    updateVehicle.VehiclePointCloudPtr->clear();
    *updateVehicle.VehiclePointCloudPtr = mergeCloud;

    updateVehicle.calcCenterAndElongation();

    discardVehicle.v3center = updateVehicle.v3center;
    discardVehicle.eigenVal = updateVehicle.eigenVal;

    discardVehicle.VehiclePointCloudPtr->clear();
    *discardVehicle.VehiclePointCloudPtr = *updateVehicle.VehiclePointCloudPtr;
}

void LiPMatch::mergePoles(Pole &updatePole, Pole &discardPole)
{
    *updatePole.PolePointCloudPtr += *discardPole.PolePointCloudPtr;

    static pcl::VoxelGrid<pcl::PointXYZI> merge_grid;
    merge_grid.setLeafSize(0.35,0.35,0.35);
    pcl::PointCloud<pcl::PointXYZI> mergeCloud;
    merge_grid.setInputCloud (updatePole.PolePointCloudPtr);
    merge_grid.filter (mergeCloud);
    updatePole.PolePointCloudPtr->clear();
    *updatePole.PolePointCloudPtr = mergeCloud;

    updatePole.calcCenterAndElongation();

    discardPole.v3center = updatePole.v3center;
    discardPole.eigenVal = updatePole.eigenVal;

    discardPole.PolePointCloudPtr->clear();
    *discardPole.PolePointCloudPtr = *updatePole.PolePointCloudPtr;
}


//only palnes
void LiPMatch::detectPlanesCloud( m_keyframe &c_keyframe, int keyFrameCount)
{
    static pcl::VoxelGrid<pcl::PointXYZI> grid_1;
    grid_1.setLeafSize(0.35,0.35,0.35);

    grid_1.setInputCloud(c_keyframe.structurelaserCloud);
    grid_1.filter (*c_keyframe.structurelaserCloud);

    static pcl::VoxelGrid<pcl::PointXYZI> grid_2;
    grid_2.setLeafSize(0.8,0.8,0.8);
    grid_2.setInputCloud(c_keyframe.surflaserCloud);
    grid_2.filter (*c_keyframe.surflaserCloud);

    static pcl::VoxelGrid<pcl::PointXYZI> grid_3;
    grid_3.setLeafSize(0.4,0.4,0.4);
    grid_3.setInputCloud(c_keyframe.linelaserCloud);
    grid_3.filter (*c_keyframe.linelaserCloud);

    grid_3.setInputCloud(c_keyframe.orilaserCloud);
    grid_3.filter (*c_keyframe.orilaserCloud);

    grid_3.setInputCloud(c_keyframe.g_laserCloud);
    grid_3.filter (*c_keyframe.g_laserCloud);

    double time_behinSeg = pcl::getTime();

    int colorid = 0;


    //聚类
    pcl::search::KdTree<pcl::PointXYZI>::Ptr tree (new pcl::search::KdTree<pcl::PointXYZI>);
    tree->setInputCloud (c_keyframe.structurelaserCloud);
    std::vector<pcl::PointIndices> cluster_indices;
    pcl::EuclideanClusterExtraction<pcl::PointXYZI> ec;
    ec.setClusterTolerance (0.8);
//    ec.setMinClusterSize (100);
    ec.setMinClusterSize (150);
    ec.setMaxClusterSize (150000);
    ec.setSearchMethod (tree);
    ec.setInputCloud (c_keyframe.structurelaserCloud);
    ec.extract (cluster_indices);
    pcl::PointCloud<pcl::PointXYZI>::Ptr laserCloudNgAftEe(new pcl::PointCloud<pcl::PointXYZI>());
    for (std::vector<pcl::PointIndices>::const_iterator it = cluster_indices.begin (); it != cluster_indices.end (); ++it)
    {
        for (std::vector<int>::const_iterator pit = it->indices.begin (); pit != it->indices.end (); ++pit)
        {
            laserCloudNgAftEe->points.push_back (c_keyframe.structurelaserCloud->points[*pit]);
        }
    }

//    pcl::PointCloud<pcl::PointXYZI>::Ptr laserCloudNgAftEe(new pcl::PointCloud<pcl::PointXYZI>());
//    laserCloudNgAftEe = c_keyframe.structurelaserCloud;

    //区域增长法提取激光点云中的平面
    pcl::search::Search<pcl::PointXYZI>::Ptr treeRg (new pcl::search::KdTree<pcl::PointXYZI>);
    pcl::PointCloud <pcl::Normal>::Ptr normals (new pcl::PointCloud <pcl::Normal>);
    pcl::NormalEstimation<pcl::PointXYZI, pcl::Normal> normal_estimator;
    normal_estimator.setSearchMethod (treeRg);
    normal_estimator.setInputCloud (laserCloudNgAftEe);
    normal_estimator.setKSearch (10);
    normal_estimator.compute (*normals);

    pcl::RegionGrowing<pcl::PointXYZI, pcl::Normal> reg;
    reg.setMinClusterSize (90);
//    reg.setMinClusterSize (120);
    reg.setMaxClusterSize (1000000);
    reg.setSearchMethod (treeRg);
    reg.setNumberOfNeighbours (20);
    reg.setInputCloud (laserCloudNgAftEe);
    reg.setInputNormals (normals);
    reg.setSmoothnessThreshold (14.0 / 180.0 * M_PI);
    reg.setCurvatureThreshold (10.0);

    std::vector <pcl::PointIndices> clusters;
    reg.extract (clusters);

    pcl::PointCloud<pcl::PointXYZI>::Ptr laserCloudNgAftReg(new pcl::PointCloud<pcl::PointXYZI>());
    //创建一个模型参数对象，用于记录结果
    pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients);
    //inliers表示误差能容忍的点 记录的是点云的序号
    pcl::PointIndices::Ptr inliers(new pcl::PointIndices);
    // 创建一个分割器
    pcl::SACSegmentation<pcl::PointXYZI> seg;
    // Optional，这个设置可以选定结果平面展示的点是分割掉的点还是分割剩下的点。
    seg.setOptimizeCoefficients(true);
    // Mandatory-设置目标几何形状areSameVehicle
    seg.setModelType(pcl::SACMODEL_PLANE);
    //分割方法：随机采样法
    seg.setMethodType(pcl::SAC_RANSAC);
    //设置误差容忍范围，也就是我说过的阈值
    seg.setDistanceThreshold(0.05);

    vector<Plane> detectedLocalPlanes;

    pcl::PointCloud<pcl::PointXYZI>::Ptr curPlanePoints(new pcl::PointCloud<pcl::PointXYZI>());

    for (size_t i = 0 ; i < clusters.size() ; ++i)
    {
        Plane plane;
        pcl::PointCloud<pcl::PointXYZI>::Ptr pointsOnPlane(new pcl::PointCloud<pcl::PointXYZI>());
        pointsOnPlane->points.clear();

        for (size_t j = 0 ; j < clusters[i].indices.size() ; ++j)
        {
            pcl::PointXYZI tmpPoint;
            tmpPoint.x = laserCloudNgAftEe->points[clusters[i].indices[j]].x;
            tmpPoint.y = laserCloudNgAftEe->points[clusters[i].indices[j]].y;
            tmpPoint.z = laserCloudNgAftEe->points[clusters[i].indices[j]].z;
            tmpPoint.intensity = i;
            pointsOnPlane->points.push_back(tmpPoint);
            laserCloudNgAftReg->points.push_back(tmpPoint);
        }

        //输入点云
        seg.setInputCloud(pointsOnPlane);
        //分割点云，获得平面和法向量
        seg.segment(*inliers, *coefficients);

        double planen[4];

        planen[0] = coefficients->values[0];
        planen[1] = coefficients->values[1];
        planen[2] = coefficients->values[2];
        planen[3] = -1.0 * coefficients->values[3];

        plane.v3normal = Vector3f(planen[0], planen[1], planen[2]);
        plane.d = planen[3];
        pcl::copyPointCloud(*pointsOnPlane, *plane.planePointCloudPtr);

        pcl::PointCloud<pcl::PointXYZI>::Ptr laserCloudInlier(new pcl::PointCloud<pcl::PointXYZI>());

        for (std::vector<int>::const_iterator pit = inliers->indices.begin (); pit != inliers->indices.end (); ++pit)
        {
            laserCloudInlier->points.push_back (pointsOnPlane->points[*pit]);
        }

        pcl::copyPointCloud(*laserCloudInlier, *plane.InplanePointCloudOriPtr);

        plane.calcConvexHull(plane.planePointCloudPtr,planen);

        plane.computeMassCenterAndArea();
        plane.calcElongationAndPpalDir();

        plane.areaVoxels= plane.planePointCloudPtr->size() * 0.0025;

        plane.keyFrameId = keyFrameCount;

        *curPlanePoints += *plane.planePointCloudPtr;

        detectedLocalPlanes.push_back(plane);
    }

//    laserCloudOri_mp1 += *curPlanePoints;


    // Merge detected planes with previous ones if they are the same
    observedPlanes.clear();
    vPlanes.clear();

    for (size_t i = 0; i < detectedLocalPlanes.size (); i++)
    {
        detectedLocalPlanes[i].id = vPlanes.size();

        // Update co-visibility graph
        for(set<unsigned>::iterator it = observedPlanes.begin(); it != observedPlanes.end(); it++)
        {
            detectedLocalPlanes[i].neighborPlanes[*it] = 1;
            vPlanes[*it].neighborPlanes[detectedLocalPlanes[i].id] = 1;
        }
        observedPlanes.insert(detectedLocalPlanes[i].id);
        vPlanes.push_back(detectedLocalPlanes[i]);
    }


    double time_endinSeg = pcl::getTime();

//    std::cout<<"plane seg time: "<<time_endinSeg-time_behinSeg<<std::endl;

    std::shared_ptr<Maps_keyframe<float>> mk = std::make_shared<Maps_keyframe<float>>();

    std::cout<<"vPlanes.size() ";
    std::cout<<vPlanes.size()<<std::endl;

    mk->vPlanes = vPlanes;
    mk->m_accumulated_point_cloud = *c_keyframe.orilaserCloud;

//    mk->m_accumulated_ng_pc = c_keyframe.g_laserCloud;

    mk->m_accumulated_g_pc = *c_keyframe.g_laserCloud;

    std::cout<<"mk->m_accumulated_g_pc.size() "<<mk->m_accumulated_g_pc.size()<<std::endl;

    mk->m_accumulated_structure_pc = *c_keyframe.structurelaserCloud;
    mk->m_accumulated_vehicle_pc = *c_keyframe.vehiclelaserCloud;

    mk->m_keyframe_idx = keyFrameCount;
    mk->m_ending_frame_idx = c_keyframe.m_ending_frame_idx;
    mk->m_accumulate_frames = c_keyframe.framecount;
    mk->m_pose_q = c_keyframe.m_pose_q;
    mk->m_pose_t = c_keyframe.m_pose_t;
    mk->m_accumulated_line_pc = *c_keyframe.linelaserCloud;
    mk->m_accumulated_surf_pc = *c_keyframe.surflaserCloud;

//    mk->m_accumulated_g_pc = c_keyframe.g_laserCloud;

    ////////////////

    Eigen::Quaterniond                                 q_curr;
    Eigen::Vector3d                                    t_curr;

    q_curr = c_keyframe.m_pose_q;
    t_curr = c_keyframe.m_pose_t;

    keyframe_vec.push_back( mk );


    map_id_pc.insert( std::make_pair( map_id_pc.size(), keyframe_vec.back()->m_accumulated_point_cloud ) );


    int curren_frame_idx = keyframe_vec.back()->m_ending_frame_idx;

    pose3d_vec.push_back( Pose3d( q_curr, t_curr ) );
    pose3d_map.insert( std::make_pair( pose3d_map.size(), Pose3d( q_curr, t_curr ) ) );

    if ( pose3d_vec.size() >= 2 )
    {
        Constraint3d temp_csn;
        Eigen::Vector3d relative_T = pose3d_vec[ pose3d_vec.size() - 2 ].q.inverse() * ( t_curr - pose3d_vec[ pose3d_vec.size() - 2 ].p );
        Eigen::Quaterniond relative_Q = pose3d_vec[ pose3d_vec.size() - 2 ].q.inverse() * q_curr;
        temp_csn = Constraint3d( pose3d_vec.size() - 2, pose3d_vec.size() - 1,relative_Q, relative_T );
        constrain_vec.push_back( temp_csn );
    }

    std::shared_ptr<Maps_keyframe<float>>& last_keyframe = keyframe_vec.back();

//    same_laserCloud.points.clear();
//    same_laserCloud2.points.clear();

    if (keyframe_vec.size() > 1) {
        std::shared_ptr<Maps_keyframe<float>>& closed_keyframe = keyframe_vec[keyframe_vec.size()-2];
        for (size_t i = 0; i < last_keyframe->vPlanes.size(); i++)
        {
            for (size_t j = 0; j < closed_keyframe->vPlanes.size(); j++)
            {
                //                0.9848  0.12  0.15
                if (areSamePlane(last_keyframe->vPlanes[i], closed_keyframe->vPlanes[j], 0.925, 0.135, 0.135))
                {
                    mergePlanes(last_keyframe->vPlanes[i], closed_keyframe->vPlanes[j]);
                }
            }
        }

        for (size_t i = 0; i < last_keyframe->vVehicles.size(); i++)
        {
            for (size_t j = 0; j < closed_keyframe->vVehicles.size(); j++)
            {
                if (areSameVehicle(last_keyframe->vVehicles[i], closed_keyframe->vVehicles[j], 0.50))
                {
                    mergeVehicles(last_keyframe->vVehicles[i], closed_keyframe->vVehicles[j]);
                }
            }
        }


        for (size_t i = 0; i < last_keyframe->vPoles.size(); i++)
        {
            for (size_t j = 0; j < closed_keyframe->vPoles.size(); j++)
            {
                if (areSamePole(last_keyframe->vPoles[i], closed_keyframe->vPoles[j], 0.450))
                {
                    mergePoles(last_keyframe->vPoles[i], closed_keyframe->vPoles[j]);
                }
            }
        }
    }



    printf( "--- Current_idx = %d, lidar_frame_idx = %d ---\r\n", keyframe_vec.size(), curren_frame_idx );

    std::map<unsigned, unsigned> bestMatch; bestMatch.clear();
    int this_kf = 0;

    float wdif_height;
    float wdif_height2;
    float wdif_normal;
    float wrel_dist_centers;
    float wal;
    float wea;


    pcl::PointXYZI pointSel;
    pointSel.x = t_curr(0);
    pointSel.y = t_curr(1);
    pointSel.z = t_curr(2);

    if (all_kfs_pose.points.size() < 5) {
        all_kfs_pose.push_back(pointSel);
        return;
    }

    m_kdtree_kfs.setInputCloud( all_kfs_pose.makeShared() );
    std::vector<int> pointSearchInd;
    std::vector<float> pointSearchSqDis;
    m_kdtree_kfs.nearestKSearch(pointSel, 20, pointSearchInd, pointSearchSqDis);
    all_kfs_pose.push_back(pointSel);

    bestMatch.clear();
    this_kf = 0;

    double aveTime = 0.0;
    int graphmatchTimes = 0;
    if (last_keyframe->vPlanes.size() > 2) {

        for (size_t his = 0; his < pointSearchInd.size(); his++) {
            if ((keyframe_vec.size() - pointSearchInd[his]) <= 5) {
                continue;
            }

            if (keyframe_vec[pointSearchInd[his]]->vPlanes.size() < 3)
                continue;

            Subgraph currentSubgraph(keyframe_vec[pointSearchInd[his]]->vPlanes, 0);
            Subgraph targetSubgraph(last_keyframe->vPlanes, 0);

            int unaycount;
            double time_begComp = pcl::getTime();
            std::map<unsigned, unsigned> resultingMatch = matcher.compareSubgraphs(currentSubgraph, targetSubgraph,
                                                                                   unaycount);

            graphmatchTimes++;

            double time_endComp = pcl::getTime();

            aveTime += time_endComp - time_begComp;

            if (resultingMatch.size() > bestMatch.size()) {
                bestMatch = resultingMatch;
                this_kf = pointSearchInd[his];

                wdif_height = matcher.wdif_height;
                wdif_height2 = matcher.wdif_height2;
                wdif_normal = matcher.wdif_normal;
                wrel_dist_centers = matcher.wrel_dist_centers;
                wal = matcher.wal;
                wea = matcher.wea;
            }
        }
    }
    else
    {
        return;
    }


    std::cout<<"comp time "<<aveTime/graphmatchTimes<<std::endl;

    std::cout<<"+++++++++++++++++++++++++++++++"<<std::endl;
    std::cout<<"this_kf "<<this_kf<<std::endl;
    std::cout<<"bestMatch.size() "<<bestMatch.size()<<std::endl;
    std::cout<<"-----------------------------"<<std::endl;

    //KITTI
    if (bestMatch.size() < 2) {
        return;
    }

    std::vector<int> firstINdexes;
    for (map<unsigned, unsigned>::iterator it = bestMatch.begin(); it != bestMatch.end(); it++) {
        firstINdexes.push_back(it->first);
    }

    pcl::PointCloud<pcl::PointXYZI> normPOints;
    for (int it = 0; it < firstINdexes.size(); ++it)
    {
        pcl::PointXYZI phe;
        phe.x = keyframe_vec[this_kf]->vPlanes[firstINdexes[it]].v3normal(0);
        phe.y = keyframe_vec[this_kf]->vPlanes[firstINdexes[it]].v3normal(1);
        phe.z = keyframe_vec[this_kf]->vPlanes[firstINdexes[it]].v3normal(2);
        normPOints.points.push_back(phe);
    }

    //聚类
    pcl::search::KdTree<pcl::PointXYZI>::Ptr tree1(new pcl::search::KdTree<pcl::PointXYZI>);
    tree1->setInputCloud(normPOints.makeShared());
    std::vector<pcl::PointIndices> cluster_indices2;
    pcl::EuclideanClusterExtraction<pcl::PointXYZI> ec1;
    ec1.setClusterTolerance(0.15);
    ec1.setMinClusterSize(1);
    ec1.setMaxClusterSize(100);
    ec1.setSearchMethod(tree1);
    ec1.setInputCloud(normPOints.makeShared());
    ec1.extract(cluster_indices2);

    std::cout<<"cluster_indices2.size() "<<cluster_indices2.size()<<std::endl;

    if (cluster_indices2.size() < 2) {
        return;
    }

    if (bestMatch.size() < 5)
        return;

    int allMatchedSize = bestMatch.size();


    std::cout<<"allMatchedSize "<<allMatchedSize<<std::endl;

//    std::cout<<"!!!!!!!!!"<<std::endl;
//    std::cout<<"wdif_height "<<wdif_height<<std::endl;
//    std::cout<<"wdif_height2 "<<wdif_height2<<std::endl;
//    std::cout<<"wrel_dist_centers "<<wrel_dist_centers<<std::endl;
//    std::cout<<"wal "<<wal<<std::endl;
//    std::cout<<"wea "<<wea<<std::endl;
//    std::cout<<"!!!!!!!!!"<<std::endl;

    swdif_height += wdif_height;
    swdif_height2 += wdif_height2;
    swrel_dist_centers += wrel_dist_centers;
    swal += wal;
    swea += wea;
    ssum++;

    std::cout<<"!!!!!!!!!"<<std::endl;
    std::cout<<"wdif_height "<<swdif_height/ssum<<std::endl;
    std::cout<<"wdif_height2 "<<swdif_height2/ssum<<std::endl;
    std::cout<<"wrel_dist_centers "<<swrel_dist_centers/ssum<<std::endl;
    std::cout<<"wal "<<swal/ssum<<std::endl;
    std::cout<<"wea "<<swea/ssum<<std::endl;
    std::cout<<"!!!!!!!!!"<<std::endl;



//    //KITTI
//    if (allMatchedSize < 7) {
//        return;
//    }


    double icp_score = 0.0;



//    scene_align.find_tranfrom_of_two_mappings(keyframe_vec[this_kf]->m_accumulated_surf_pc, keyframe_vec[this_kf]->m_accumulated_line_pc,
//                                              last_keyframe->m_accumulated_surf_pc, last_keyframe->m_accumulated_line_pc,
//                                              icp_score, quaternion, trans, init_cost, final_cost);



//    std::cout<<icp_score<<"  "<<init_cost<<"  "<<final_cost<<std::endl;

//    printf("ICP inlier threshold = %lf\r\n", icp_score);
//
//    auto Q_a = pose3d_vec[this_kf].q;
//    auto Q_b = pose3d_vec[pose3d_vec.size() - 1].q;
//    auto T_a = pose3d_vec[this_kf].p;
//    auto T_b = pose3d_vec[pose3d_vec.size() - 1].p;
//    auto ICP_q = scene_align.m_q_w_curr;
//    auto ICP_t = scene_align.m_t_w_curr;
//
//    ICP_t = ( ICP_q.inverse() * ( -ICP_t ) );
//    ICP_q = ICP_q.inverse();
//
//    std::cout << "ICP_q = " << ICP_q.coeffs().transpose() << std::endl;
//    std::cout << "ICP_t = " << ICP_t.transpose() << std::endl;

    //KITTI
//    if ( icp_score < 0.31 )
//    if ( icp_score < 0.35 )
//    if ( icp_score < 0.33 && final_cost > 50.0)
    {

        printf("I believe this is true loop.\r\n");

//        VectorOfConstraints constrain_vec_temp;
//        constrain_vec_temp = constrain_vec;
//
//        /*闭环约束*/
//        Constraint3d pose_constrain;
//        auto q_res = Q_b.inverse() * ICP_q.inverse() * Q_a;
//        //q_res = q_res.inverse();
//        auto t_res = Q_b.inverse() * ( ICP_q.inverse() * ( T_a - ICP_t ) - T_b );
//        //t_res = q_res.inverse()*(-t_res);
//        //q_res = q_res.inverse();
//
////                cout << "=== Add_constrain_of_loop ====" << endl;
////                cout << Q_a.coeffs().transpose() << endl;
////                cout << Q_b.coeffs().transpose() << endl;
////                cout << ICP_q.coeffs().transpose() << endl;
////                cout << T_a.transpose() << endl;
////                cout << T_b.transpose() << endl;
////                cout << ICP_t.transpose() << endl;
////                cout << "Result: " << endl;
////                cout << q_res.coeffs().transpose() << endl;
////                cout << t_res.transpose() << endl;
//
//        //t_res.setZero();
//        pose_constrain.id_begin = pose3d_vec.size() - 1;
//        pose_constrain.id_end = this_kf;
//        pose_constrain.t_be.p = t_res;
//        pose_constrain.t_be.q = q_res;
//        /*闭环约束*/


        loop_closure_matchedid[pose3d_vec.size() - 1] = this_kf;

//        constrain_vec_temp.push_back( pose_constrain );
//        pose3d_map_ori = pose3d_map;
//        auto temp_pose_3d_map = pose3d_map;
//        pose_graph_optimization(temp_pose_3d_map, constrain_vec_temp);
//        optimized_pose3d_map = temp_pose_3d_map;

//        refined_pt = map_rfn.refine_pointcloud( map_id_pc, pose3d_map_ori, temp_pose_3d_map, ( int ) map_id_pc.size() - 1);
//        refined_pt.points.clear();
//        refined_pt_bef.points.clear();
//
//        for ( int pc_idx = ( int ) map_id_pc.size() - 1; pc_idx >= 0; pc_idx -= 2 )
//        {
//            refined_pt += map_rfn.refine_pointcloud( map_id_pc, pose3d_map_ori, temp_pose_3d_map, pc_idx);
//            refined_pt_bef += map_rfn.refine_pointcloud( map_id_pc, pose3d_map_ori, pose3d_map_ori, pc_idx);
//        }
    }
}





//void LiPMatch::detectPlanesCloud( m_keyframe &c_keyframe, int keyFrameCount)
//{
//    static pcl::VoxelGrid<pcl::PointXYZI> grid_1;
//    grid_1.setLeafSize(0.35,0.35,0.35);
//
//    grid_1.setInputCloud(c_keyframe.structurelaserCloud);
//    grid_1.filter (*c_keyframe.structurelaserCloud);
//
//    grid_1.setLeafSize(0.20,0.20,0.20);
//    grid_1.setInputCloud(c_keyframe.vehiclelaserCloud);
//    grid_1.filter (*c_keyframe.vehiclelaserCloud);
//
//    grid_1.setLeafSize(0.35,0.35,0.35);
//    grid_1.setInputCloud(c_keyframe.naturelaserCloud);
//    grid_1.filter (*c_keyframe.naturelaserCloud);
//
//
//    static pcl::VoxelGrid<pcl::PointXYZI> grid_2;
//    grid_2.setLeafSize(0.8,0.8,0.8);
//    grid_2.setInputCloud(c_keyframe.surflaserCloud);
//    grid_2.filter (*c_keyframe.surflaserCloud);
//
//    static pcl::VoxelGrid<pcl::PointXYZI> grid_3;
//    grid_3.setLeafSize(0.4,0.4,0.4);
//    grid_3.setInputCloud(c_keyframe.linelaserCloud);
//    grid_3.filter (*c_keyframe.linelaserCloud);
//
//    grid_3.setInputCloud(c_keyframe.orilaserCloud);
//    grid_3.filter (*c_keyframe.orilaserCloud);
//
//    grid_3.setInputCloud(c_keyframe.g_laserCloud);
//    grid_3.filter (*c_keyframe.g_laserCloud);
//
//    double time_behinSeg = pcl::getTime();
//
//    //////////////////////
//
////    std::cout<<"bef: "<<c_keyframe.vehiclelaserCloud->points.size()<<std::endl;
////    pcl::PointCloud<pcl::PointXYZI>::Ptr cloud_filter(new pcl::PointCloud<pcl::PointXYZI>);
////    pcl::StatisticalOutlierRemoval<pcl::PointXYZI> sor;
////    sor.setInputCloud(c_keyframe.vehiclelaserCloud);
//////    sor.setRadiusSearch(0.35);
//////    sor.setMinNeighborsInRadius(15);
////    sor.setMeanK(5);   //设置在进行统计时考虑查询点邻近点数
////    sor.setStddevMulThresh(1.0);
////    sor.setNegative(false);
////    sor.filter(*cloud_filter);
////    *c_keyframe.vehiclelaserCloud = *cloud_filter;
////    std::cout<<"aft: "<<c_keyframe.vehiclelaserCloud->points.size()<<std::endl;
//
//
//    int colorid = 0;
//    //聚类
//    pcl::search::KdTree<pcl::PointXYZI>::Ptr treeVehicle (new pcl::search::KdTree<pcl::PointXYZI>);
//    treeVehicle->setInputCloud (c_keyframe.vehiclelaserCloud);
//    std::vector<pcl::PointIndices> cluster_indices_vehicle;
//    pcl::EuclideanClusterExtraction<pcl::PointXYZI> ec_vehicle;
//    ec_vehicle.setClusterTolerance (0.22);
////    ec.setMinClusterSize (100);
//    ec_vehicle.setMinClusterSize (85);
//    ec_vehicle.setMaxClusterSize (150000);
//    ec_vehicle.setSearchMethod (treeVehicle);
//    ec_vehicle.setInputCloud (c_keyframe.vehiclelaserCloud);
//    ec_vehicle.extract (cluster_indices_vehicle);
//    pcl::PointCloud<pcl::PointXYZI>::Ptr laserCloudNgAftEe_vehicles(new pcl::PointCloud<pcl::PointXYZI>());
//    pcl::PCA< pcl::PointXYZI > pca;
//
//    vector<Vehicle> detectedLocalVehicles;
//
//    for (std::vector<pcl::PointIndices>::const_iterator it = cluster_indices_vehicle.begin (); it != cluster_indices_vehicle.end (); ++it)
//    {
//        pcl::PointCloud<pcl::PointXYZI>::Ptr laserCloudNgAftEe_vehicle(new pcl::PointCloud<pcl::PointXYZI>());
//        for (std::vector<int>::const_iterator pit = it->indices.begin (); pit != it->indices.end (); ++pit)
//        {
//            c_keyframe.vehiclelaserCloud->points[*pit].intensity = colorid;
//            laserCloudNgAftEe_vehicle->points.push_back (c_keyframe.vehiclelaserCloud->points[*pit]);
//        }
//        pca.setInputCloud(laserCloudNgAftEe_vehicle);
//        Eigen::VectorXf eigenVal = pca.getEigenValues();
//
//        if (eigenVal[2] / eigenVal[0] < 0.005)
//            continue;
//
//        *laserCloudNgAftEe_vehicles += *laserCloudNgAftEe_vehicle;
//
//        colorid++;
//
////        std::cout<<eigenVal[0]<<" "<<eigenVal[1]<<" "<<eigenVal[2]<<std::endl;
//
//        Vehicle vc;
//        vc.VehiclePointCloudPtr = laserCloudNgAftEe_vehicle;
//        vc.keyFrameId = keyFrameCount;
//        vc.calcCenterAndElongation();
//
//        detectedLocalVehicles.push_back(vc);
//
//    }
//
//    laserCloudOri_mp1 += *laserCloudNgAftEe_vehicles;
//
//    observedVehicles.clear();
//    vVehicles.clear();
//
//    for (size_t i = 0; i < detectedLocalVehicles.size (); i++)
//    {
//        detectedLocalVehicles[i].id = vVehicles.size();
//
//        // Update co-visibility graph
//        for(set<unsigned>::iterator it = observedVehicles.begin(); it != observedVehicles.end(); it++)
//        {
//            detectedLocalVehicles[i].neighborVehicles[*it] = 1;
//            vVehicles[*it].neighborVehicles[detectedLocalVehicles[i].id] = 1;
//        }
//        observedVehicles.insert(detectedLocalVehicles[i].id);
//        vVehicles.push_back(detectedLocalVehicles[i]);
//    }
//
//
//    std::shared_ptr<Maps_keyframe<float>> mk = std::make_shared<Maps_keyframe<float>>();
//
//    std::cout<<"vVehicles.size() "<<vVehicles.size()<<std::endl;
//
//    mk->vVehicles = vVehicles;
//
//    //聚类
//    pcl::search::KdTree<pcl::PointXYZI>::Ptr treeNature (new pcl::search::KdTree<pcl::PointXYZI>);
//    treeNature->setInputCloud (c_keyframe.naturelaserCloud);
//    std::vector<pcl::PointIndices> cluster_indices_nature;
//    pcl::EuclideanClusterExtraction<pcl::PointXYZI> ec_nature;
//    ec_nature.setClusterTolerance (0.45);
////    ec.setMinClusterSize (100);
//    ec_nature.setMinClusterSize (17);
//    ec_nature.setMaxClusterSize (150000);
//    ec_nature.setSearchMethod (treeNature);
//    ec_nature.setInputCloud (c_keyframe.naturelaserCloud);
//    ec_nature.extract (cluster_indices_nature);
//    pcl::PointCloud<pcl::PointXYZI>::Ptr laserCloudNgAftEe_natures(new pcl::PointCloud<pcl::PointXYZI>());
//    pcl::PCA< pcl::PointXYZI > pca1;
//
//    vector<Pole> detectedLocalPoles;
//
//    colorid = 0;
//    for (std::vector<pcl::PointIndices>::const_iterator it = cluster_indices_nature.begin (); it != cluster_indices_nature.end (); ++it)
//    {
//        pcl::PointCloud<pcl::PointXYZI>::Ptr laserCloudNgAftEe_nature(new pcl::PointCloud<pcl::PointXYZI>());
//        for (std::vector<int>::const_iterator pit = it->indices.begin (); pit != it->indices.end (); ++pit)
//        {
//            c_keyframe.naturelaserCloud->points[*pit].intensity = colorid;
//            laserCloudNgAftEe_nature->points.push_back (c_keyframe.naturelaserCloud->points[*pit]);
//        }
//        pca1.setInputCloud(laserCloudNgAftEe_nature);
//        Eigen::VectorXf eigenVal = pca1.getEigenValues();
//
//        if (eigenVal[1] / eigenVal[0] > 0.17)
//            continue;
//
//        *laserCloudNgAftEe_natures += *laserCloudNgAftEe_nature;
//        colorid++;
//
//        Pole vc;
//        vc.PolePointCloudPtr = laserCloudNgAftEe_nature;
//        vc.keyFrameId = keyFrameCount;
//        vc.calcCenterAndElongation();
//
//        detectedLocalPoles.push_back(vc);
//
////        std::cout<<eigenVal[0]<<" "<<eigenVal[1]<<" "<<eigenVal[2]<<std::endl;
//
//    }
//
//    laserCloudOri_mp1 += *laserCloudNgAftEe_natures;
//
//    observedPoles.clear();
//    vPoles.clear();
//
//    for (size_t i = 0; i < detectedLocalPoles.size (); i++)
//    {
//        detectedLocalPoles[i].id = vPoles.size();
//
//        // Update co-visibility graph
//        for(set<unsigned>::iterator it = observedPoles.begin(); it != observedPoles.end(); it++)
//        {
//            detectedLocalPoles[i].neighborPoles[*it] = 1;
//            vPoles[*it].neighborPoles[detectedLocalPoles[i].id] = 1;
//        }
//        observedPoles.insert(detectedLocalPoles[i].id);
//        vPoles.push_back(detectedLocalPoles[i]);
//    }
//
//    std::cout<<"vPoles.size() "<<vPoles.size()<<std::endl;
//
//    mk->vPoles = vPoles;
//
//
//    /////////////////////
//
//    //聚类
//    pcl::search::KdTree<pcl::PointXYZI>::Ptr tree (new pcl::search::KdTree<pcl::PointXYZI>);
//    tree->setInputCloud (c_keyframe.structurelaserCloud);
//    std::vector<pcl::PointIndices> cluster_indices;
//    pcl::EuclideanClusterExtraction<pcl::PointXYZI> ec;
//    ec.setClusterTolerance (0.8);
////    ec.setMinClusterSize (100);
//    ec.setMinClusterSize (150);
//    ec.setMaxClusterSize (150000);
//    ec.setSearchMethod (tree);
//    ec.setInputCloud (c_keyframe.structurelaserCloud);
//    ec.extract (cluster_indices);
//    pcl::PointCloud<pcl::PointXYZI>::Ptr laserCloudNgAftEe(new pcl::PointCloud<pcl::PointXYZI>());
//    for (std::vector<pcl::PointIndices>::const_iterator it = cluster_indices.begin (); it != cluster_indices.end (); ++it)
//    {
//        for (std::vector<int>::const_iterator pit = it->indices.begin (); pit != it->indices.end (); ++pit)
//        {
//            laserCloudNgAftEe->points.push_back (c_keyframe.structurelaserCloud->points[*pit]);
//        }
//    }
//
////    pcl::PointCloud<pcl::PointXYZI>::Ptr laserCloudNgAftEe(new pcl::PointCloud<pcl::PointXYZI>());
////    laserCloudNgAftEe = c_keyframe.structurelaserCloud;
//
//    //区域增长法提取激光点云中的平面
//    pcl::search::Search<pcl::PointXYZI>::Ptr treeRg (new pcl::search::KdTree<pcl::PointXYZI>);
//    pcl::PointCloud <pcl::Normal>::Ptr normals (new pcl::PointCloud <pcl::Normal>);
//    pcl::NormalEstimation<pcl::PointXYZI, pcl::Normal> normal_estimator;
//    normal_estimator.setSearchMethod (treeRg);
//    normal_estimator.setInputCloud (laserCloudNgAftEe);
//    normal_estimator.setKSearch (10);
//    normal_estimator.compute (*normals);
//
//    pcl::RegionGrowing<pcl::PointXYZI, pcl::Normal> reg;
//    reg.setMinClusterSize (90);
////    reg.setMinClusterSize (120);
//    reg.setMaxClusterSize (1000000);
//    reg.setSearchMethod (treeRg);
//    reg.setNumberOfNeighbours (20);
//    reg.setInputCloud (laserCloudNgAftEe);
//    reg.setInputNormals (normals);
//    reg.setSmoothnessThreshold (14.0 / 180.0 * M_PI);
//    reg.setCurvatureThreshold (10.0);
//
//    std::vector <pcl::PointIndices> clusters;
//    reg.extract (clusters);
//
//    pcl::PointCloud<pcl::PointXYZI>::Ptr laserCloudNgAftReg(new pcl::PointCloud<pcl::PointXYZI>());
//    //创建一个模型参数对象，用于记录结果
//    pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients);
//    //inliers表示误差能容忍的点 记录的是点云的序号
//    pcl::PointIndices::Ptr inliers(new pcl::PointIndices);
//    // 创建一个分割器
//    pcl::SACSegmentation<pcl::PointXYZI> seg;
//    // Optional，这个设置可以选定结果平面展示的点是分割掉的点还是分割剩下的点。
//    seg.setOptimizeCoefficients(true);
//    // Mandatory-设置目标几何形状areSameVehicle
//    seg.setModelType(pcl::SACMODEL_PLANE);
//    //分割方法：随机采样法
//    seg.setMethodType(pcl::SAC_RANSAC);
//    //设置误差容忍范围，也就是我说过的阈值
//    seg.setDistanceThreshold(0.05);
//
//    vector<Plane> detectedLocalPlanes;
//
//    pcl::PointCloud<pcl::PointXYZI>::Ptr curPlanePoints(new pcl::PointCloud<pcl::PointXYZI>());
//
//    for (size_t i = 0 ; i < clusters.size() ; ++i)
//    {
//        Plane plane;
//        pcl::PointCloud<pcl::PointXYZI>::Ptr pointsOnPlane(new pcl::PointCloud<pcl::PointXYZI>());
//        pointsOnPlane->points.clear();
//
//        for (size_t j = 0 ; j < clusters[i].indices.size() ; ++j)
//        {
//            pcl::PointXYZI tmpPoint;
//            tmpPoint.x = laserCloudNgAftEe->points[clusters[i].indices[j]].x;
//            tmpPoint.y = laserCloudNgAftEe->points[clusters[i].indices[j]].y;
//            tmpPoint.z = laserCloudNgAftEe->points[clusters[i].indices[j]].z;
//            tmpPoint.intensity = i;
//            pointsOnPlane->points.push_back(tmpPoint);
//            laserCloudNgAftReg->points.push_back(tmpPoint);
//        }
//
//        //输入点云
//        seg.setInputCloud(pointsOnPlane);
//        //分割点云，获得平面和法向量
//        seg.segment(*inliers, *coefficients);
//
//        double planen[4];
//
//        planen[0] = coefficients->values[0];
//        planen[1] = coefficients->values[1];
//        planen[2] = coefficients->values[2];
//        planen[3] = -1.0 * coefficients->values[3];
//
//        plane.v3normal = Vector3f(planen[0], planen[1], planen[2]);
//        plane.d = planen[3];
//        pcl::copyPointCloud(*pointsOnPlane, *plane.planePointCloudPtr);
//
//        pcl::PointCloud<pcl::PointXYZI>::Ptr laserCloudInlier(new pcl::PointCloud<pcl::PointXYZI>());
//
//        for (std::vector<int>::const_iterator pit = inliers->indices.begin (); pit != inliers->indices.end (); ++pit)
//        {
//            laserCloudInlier->points.push_back (pointsOnPlane->points[*pit]);
//        }
//
//        pcl::copyPointCloud(*laserCloudInlier, *plane.InplanePointCloudOriPtr);
//
//        plane.calcConvexHull(plane.planePointCloudPtr,planen);
//
//        plane.computeMassCenterAndArea();
//        plane.calcElongationAndPpalDir();
//
//        plane.areaVoxels= plane.planePointCloudPtr->size() * 0.0025;
//
//        plane.keyFrameId = keyFrameCount;
//
//        *curPlanePoints += *plane.planePointCloudPtr;
//
//        detectedLocalPlanes.push_back(plane);
//    }
//
//    laserCloudOri_mp1 += *curPlanePoints;
//
////    static pcl::VoxelGrid<pcl::PointXYZI> grid_t;
////    grid_t.setLeafSize(0.3,0.3,0.3);
////
////    grid_t.setInputCloud(laserCloudOri_mp1.makeShared());
////    grid_t.filter (laserCloudOri_mp1);
//
//
////    std::cout<<"detectedLocalPlanes.size() "<<detectedLocalPlanes.size ()<<std::endl;
//
//
//
//    // Merge detected planes with previous ones if they are the same
//    observedPlanes.clear();
//    vPlanes.clear();
//
//    for (size_t i = 0; i < detectedLocalPlanes.size (); i++)
//    {
//        detectedLocalPlanes[i].id = vPlanes.size();
//
//        // Update co-visibility graph
//        for(set<unsigned>::iterator it = observedPlanes.begin(); it != observedPlanes.end(); it++)
//        {
//            detectedLocalPlanes[i].neighborPlanes[*it] = 1;
//            vPlanes[*it].neighborPlanes[detectedLocalPlanes[i].id] = 1;
//        }
//        observedPlanes.insert(detectedLocalPlanes[i].id);
//        vPlanes.push_back(detectedLocalPlanes[i]);
//    }
//
//
//
//
//    double time_endinSeg = pcl::getTime();
//
////    std::cout<<"plane seg time: "<<time_endinSeg-time_behinSeg<<std::endl;
//
////    std::shared_ptr<Maps_keyframe<float>> mk = std::make_shared<Maps_keyframe<float>>();
//
//    std::cout<<"vPlanes.size() ";
//    std::cout<<vPlanes.size()<<std::endl;
//
//    mk->vPlanes = vPlanes;
//    mk->m_accumulated_point_cloud = *c_keyframe.orilaserCloud;
//
////    mk->m_accumulated_ng_pc = c_keyframe.g_laserCloud;
//
//    mk->m_accumulated_g_pc = *c_keyframe.g_laserCloud;
//
//    std::cout<<"mk->m_accumulated_g_pc.size() "<<mk->m_accumulated_g_pc.size()<<std::endl;
//
//    mk->m_accumulated_structure_pc = *c_keyframe.structurelaserCloud;
//    mk->m_accumulated_vehicle_pc = *c_keyframe.vehiclelaserCloud;
//
//    mk->m_keyframe_idx = keyFrameCount;
//    mk->m_ending_frame_idx = c_keyframe.m_ending_frame_idx;
//    mk->m_accumulate_frames = c_keyframe.framecount;
//    mk->m_pose_q = c_keyframe.m_pose_q;
//    mk->m_pose_t = c_keyframe.m_pose_t;
//    mk->m_accumulated_line_pc = *c_keyframe.linelaserCloud;
//    mk->m_accumulated_surf_pc = *c_keyframe.surflaserCloud;
//
////    mk->m_accumulated_g_pc = c_keyframe.g_laserCloud;
//
//    ////////////////
//
//    Eigen::Quaterniond                                 q_curr;
//    Eigen::Vector3d                                    t_curr;
//
//    q_curr = c_keyframe.m_pose_q;
//    t_curr = c_keyframe.m_pose_t;
//
//    keyframe_vec.push_back( mk );
//
//
//    map_id_pc.insert( std::make_pair( map_id_pc.size(), keyframe_vec.back()->m_accumulated_point_cloud ) );
//
//
//    int curren_frame_idx = keyframe_vec.back()->m_ending_frame_idx;
//
//    pose3d_vec.push_back( Pose3d( q_curr, t_curr ) );
//    pose3d_map.insert( std::make_pair( pose3d_map.size(), Pose3d( q_curr, t_curr ) ) );
//
//    if ( pose3d_vec.size() >= 2 )
//    {
//        Constraint3d temp_csn;
//        Eigen::Vector3d relative_T = pose3d_vec[ pose3d_vec.size() - 2 ].q.inverse() * ( t_curr - pose3d_vec[ pose3d_vec.size() - 2 ].p );
//        Eigen::Quaterniond relative_Q = pose3d_vec[ pose3d_vec.size() - 2 ].q.inverse() * q_curr;
//        temp_csn = Constraint3d( pose3d_vec.size() - 2, pose3d_vec.size() - 1,relative_Q, relative_T );
//        constrain_vec.push_back( temp_csn );
//    }
//
//    std::shared_ptr<Maps_keyframe<float>>& last_keyframe = keyframe_vec.back();
//
////    same_laserCloud.points.clear();
////    same_laserCloud2.points.clear();
//
//    if (keyframe_vec.size() > 1) {
//        std::shared_ptr<Maps_keyframe<float>>& closed_keyframe = keyframe_vec[keyframe_vec.size()-2];
//        for (size_t i = 0; i < last_keyframe->vPlanes.size(); i++)
//        {
//            for (size_t j = 0; j < closed_keyframe->vPlanes.size(); j++)
//            {
//                //                0.9848  0.12  0.15
//                if (areSamePlane(last_keyframe->vPlanes[i], closed_keyframe->vPlanes[j], 0.925, 0.135, 0.135))
//                {
//                    mergePlanes(last_keyframe->vPlanes[i], closed_keyframe->vPlanes[j]);
//                }
//            }
//        }
//
//        for (size_t i = 0; i < last_keyframe->vVehicles.size(); i++)
//        {
//            for (size_t j = 0; j < closed_keyframe->vVehicles.size(); j++)
//            {
//                if (areSameVehicle(last_keyframe->vVehicles[i], closed_keyframe->vVehicles[j], 0.50))
//                {
//                    mergeVehicles(last_keyframe->vVehicles[i], closed_keyframe->vVehicles[j]);
//                }
//            }
//        }
//
//
//        for (size_t i = 0; i < last_keyframe->vPoles.size(); i++)
//        {
//            for (size_t j = 0; j < closed_keyframe->vPoles.size(); j++)
//            {
//                if (areSamePole(last_keyframe->vPoles[i], closed_keyframe->vPoles[j], 0.450))
//                {
//                    mergePoles(last_keyframe->vPoles[i], closed_keyframe->vPoles[j]);
//                }
//            }
//        }
//    }
//
//
//
//    printf( "--- Current_idx = %d, lidar_frame_idx = %d ---\r\n", keyframe_vec.size(), curren_frame_idx );
//
//    std::map<unsigned, unsigned> bestMatch; bestMatch.clear();
//    int this_kf = 0;
//
//    float wdif_height;
//    float wdif_height2;
//    float wdif_normal;
//    float wrel_dist_centers;
//    float wal;
//    float wea;
//
//
//    pcl::PointXYZI pointSel;
//    pointSel.x = t_curr(0);
//    pointSel.y = t_curr(1);
//    pointSel.z = t_curr(2);
//
//    if (all_kfs_pose.points.size() < 5) {
//        all_kfs_pose.push_back(pointSel);
//
//        //    //update map
//        size_t numPrevPlanes = mapPlanes.size();
//        for (size_t i = 0; i < detectedLocalPlanes.size (); i++)
//        {
//            // Check similarity with previous planes detected
//            bool isSamePlane = false;
//            vector<Plane>::iterator itPlane = mapPlanes.begin();
//            for (size_t j = 0; j < numPrevPlanes; j++, itPlane++)
//            {
//                if (areSamePlane(mapPlanes[j], detectedLocalPlanes[i], 0.925, 0.135, 0.135))
//                {
//                    isSamePlane = true;
//                    mergePlanes2(mapPlanes[j], detectedLocalPlanes[i]);
//                    itPlane++;
//
////                for(size_t k = j+1; k < numPrevPlanes; k++, itPlane++)
////                    if (areSamePlane(mapPlanes[j], mapPlanes[k], 0.925, 0.135, 0.135))
////                    {
////                        mergePlanes(mapPlanes[j], mapPlanes[k]);
////                        mapPlanes.erase(itPlane);
////                        --numPrevPlanes;
////                    }
//                    break;
//                }
//            }
//            if(!isSamePlane)
//            {
//                mapPlanes.push_back(detectedLocalPlanes[i]);
//            }
//        }
//        std::cout<<"mapPlanes.size() "<<mapPlanes.size()<<std::endl;
//        //update map
//        return;
//    }
//
//
//
//    m_kdtree_kfs.setInputCloud( all_kfs_pose.makeShared() );
//    std::vector<int> pointSearchInd;
//    std::vector<float> pointSearchSqDis;
//    m_kdtree_kfs.nearestKSearch(pointSel, 20, pointSearchInd, pointSearchSqDis);
//    all_kfs_pose.push_back(pointSel);
//
//    bestMatch.clear();
//    this_kf = 0;
//
//    double aveTime = 0.0;
//    int graphmatchTimes = 0;
//    if (last_keyframe->vPlanes.size() > 2) {
//
//        for (size_t his = 0; his < pointSearchInd.size(); his++) {
//            if ((keyframe_vec.size() - pointSearchInd[his]) <= 5) {
//                continue;
//            }
//
//            if (keyframe_vec[pointSearchInd[his]]->vPlanes.size() < 3)
//                continue;
//
//            Subgraph currentSubgraph(keyframe_vec[pointSearchInd[his]]->vPlanes, 0);
//            Subgraph targetSubgraph(last_keyframe->vPlanes, 0);
//
//            int unaycount;
//            double time_begComp = pcl::getTime();
//            std::map<unsigned, unsigned> resultingMatch = matcher.compareSubgraphs(currentSubgraph, targetSubgraph,
//                                                                                   unaycount);
//
//            graphmatchTimes++;
//
//            double time_endComp = pcl::getTime();
//
//            aveTime += time_endComp - time_begComp;
//
//            if (resultingMatch.size() > bestMatch.size()) {
//                bestMatch = resultingMatch;
//                this_kf = pointSearchInd[his];
//
//                wdif_height = matcher.wdif_height;
//                wdif_height2 = matcher.wdif_height2;
//                wdif_normal = matcher.wdif_normal;
//                wrel_dist_centers = matcher.wrel_dist_centers;
//                wal = matcher.wal;
//                wea = matcher.wea;
//            }
//        }
//    }
//
////    std::cout<<"!!!!!!!!!"<<std::endl;
////    std::cout<<"wdif_height "<<wdif_height<<std::endl;
////    std::cout<<"wdif_height2 "<<wdif_height2<<std::endl;
////    std::cout<<"wdif_normal "<<wdif_normal<<std::endl;
////    std::cout<<"wrel_dist_centers "<<wrel_dist_centers<<std::endl;
////    std::cout<<"!!!!!!!!!"<<std::endl;
//
//
//    std::cout<<"comp time "<<aveTime/graphmatchTimes<<std::endl;
//
//    std::vector<Eigen::Vector3f> kvc;
//    std::vector<Eigen::Vector3f> lvc;
//    std::vector<Eigen::Vector3f> kvn;
//    std::vector<Eigen::Vector3f> lvn;
//
//    for (map<unsigned, unsigned>::iterator it = bestMatch.begin(); it != bestMatch.end(); it++)
//    {
//        kvc.push_back(keyframe_vec[this_kf]->vPlanes[it->first].v3center);
//        lvc.push_back(last_keyframe->vPlanes[it->second].v3center);
//        kvn.push_back(keyframe_vec[this_kf]->vPlanes[it->first].v3normal);
//        lvn.push_back(last_keyframe->vPlanes[it->second].v3normal);
//    }
//
//    double aveTime1 = 0.0;
//    int graphmatchTimes1 = 0;
//
//    //KITTI
//    std::map<unsigned, unsigned> bestMatchVehicle; bestMatchVehicle.clear();
//    int this_kf_vehicle = 0;
//
//    if (last_keyframe->vVehicles.size() > 2) {
//
//        for (size_t his = 0; his < pointSearchInd.size(); his++) {
//            if ((keyframe_vec.size() - pointSearchInd[his]) <= 5) {
//                continue;
//            }
//
//            if (keyframe_vec[pointSearchInd[his]]->vVehicles.size() < 3)
//                continue;
//
//            Subgraph currentSubgraph(keyframe_vec[pointSearchInd[his]]->vVehicles, 0);
//            Subgraph targetSubgraph(last_keyframe->vVehicles, 0);
//
//
//            double time_begComp = pcl::getTime();
//
//            graphmatchTimes1++;
//
//
//            int unaycount;
//            std::map<unsigned, unsigned> resultingMatch = matcher.compareSubgraphsVehiclePlaneRef(currentSubgraph, targetSubgraph, unaycount, kvc,
//                                                                                                  lvc, kvn, lvn);
//
//            double time_endComp = pcl::getTime();
//
//            aveTime1 += time_endComp - time_begComp;
//
//
//            if (resultingMatch.size() > bestMatchVehicle.size()) {
//                bestMatchVehicle = resultingMatch;
//                this_kf_vehicle = pointSearchInd[his];
//            }
//        }
//    }
//
//
//    std::map<unsigned, unsigned> bestMatchPole; bestMatchPole.clear();
//    int this_kf_pole = 0;
//
//    if (last_keyframe->vPoles.size() > 2) {
//
//        for (size_t his = 0; his < pointSearchInd.size(); his++) {
//            if ((keyframe_vec.size() - pointSearchInd[his]) <= 5) {
//                continue;
//            }
//
//            if (keyframe_vec[pointSearchInd[his]]->vPoles.size() < 3)
//                continue;
//
//            Subgraph currentSubgraph(keyframe_vec[pointSearchInd[his]]->vPoles, 0);
//            Subgraph targetSubgraph(last_keyframe->vPoles, 0);
//
//
//            double time_begComp = pcl::getTime();
//
//            graphmatchTimes1++;
//
//            int unaycount;
//            std::map<unsigned, unsigned> resultingMatch = matcher.compareSubgraphsPolePlaneRef(currentSubgraph, targetSubgraph, unaycount, kvc,
//                                                                                                  lvc, kvn, lvn);
//
//            double time_endComp = pcl::getTime();
//
//            aveTime1 += time_endComp - time_begComp;
//
//
//            if (resultingMatch.size() > bestMatchPole.size()) {
//                bestMatchPole = resultingMatch;
//                this_kf_pole = pointSearchInd[his];
//            }
//        }
//    }
//
//    std::cout<<"comp time 1: "<<aveTime1/graphmatchTimes1<<std::endl;
//
//
//    std::cout<<"+++++++++++++++++++++++++++++++"<<std::endl;
//    std::cout<<"this_kf "<<this_kf<<std::endl;
//    std::cout<<"this_kf_pole "<<this_kf_pole<<std::endl;
//    std::cout<<"this_kf_vehicle "<<this_kf_vehicle<<std::endl;
//    std::cout<<"=================="<<std::endl;
//    std::cout<<"bestMatch.size() "<<bestMatch.size()<<std::endl;
//    std::cout<<"bestMatchPole.size() "<<bestMatchPole.size()<<std::endl;
//    std::cout<<"bestMatchVehicle.size() "<<bestMatchVehicle.size()<<std::endl;
//    std::cout<<"-----------------------------"<<std::endl;
//
//    //KITTI
//    if (bestMatch.size() < 2) {
//        //    //update map
//        size_t numPrevPlanes = mapPlanes.size();
//        for (size_t i = 0; i < detectedLocalPlanes.size (); i++)
//        {
//            // Check similarity with previous planes detected
//            bool isSamePlane = false;
//            vector<Plane>::iterator itPlane = mapPlanes.begin();
//            for (size_t j = 0; j < numPrevPlanes; j++, itPlane++)
//            {
//                if (areSamePlane(mapPlanes[j], detectedLocalPlanes[i], 0.925, 0.135, 0.135))
//                {
//                    isSamePlane = true;
//                    mergePlanes2(mapPlanes[j], detectedLocalPlanes[i]);
//                    itPlane++;
//
////                for(size_t k = j+1; k < numPrevPlanes; k++, itPlane++)
////                    if (areSamePlane(mapPlanes[j], mapPlanes[k], 0.925, 0.135, 0.135))
////                    {
////                        mergePlanes(mapPlanes[j], mapPlanes[k]);
////                        mapPlanes.erase(itPlane);
////                        --numPrevPlanes;
////                    }
//                    break;
//                }
//            }
//            if(!isSamePlane)
//            {
//                mapPlanes.push_back(detectedLocalPlanes[i]);
//            }
//        }
//        std::cout<<"mapPlanes.size() "<<mapPlanes.size()<<std::endl;
//        //update map
//        return;
//    }
//
//    std::vector<int> firstINdexes;
//    for (map<unsigned, unsigned>::iterator it = bestMatch.begin(); it != bestMatch.end(); it++) {
//        firstINdexes.push_back(it->first);
//    }
//
//    pcl::PointCloud<pcl::PointXYZI> normPOints;
//    for (int it = 0; it < firstINdexes.size(); ++it)
//    {
//        pcl::PointXYZI phe;
//        phe.x = keyframe_vec[this_kf]->vPlanes[firstINdexes[it]].v3normal(0);
//        phe.y = keyframe_vec[this_kf]->vPlanes[firstINdexes[it]].v3normal(1);
//        phe.z = keyframe_vec[this_kf]->vPlanes[firstINdexes[it]].v3normal(2);
//        normPOints.points.push_back(phe);
//    }
//
//    //聚类
//    pcl::search::KdTree<pcl::PointXYZI>::Ptr tree1(new pcl::search::KdTree<pcl::PointXYZI>);
//    tree1->setInputCloud(normPOints.makeShared());
//    std::vector<pcl::PointIndices> cluster_indices2;
//    pcl::EuclideanClusterExtraction<pcl::PointXYZI> ec1;
//    ec1.setClusterTolerance(0.15);
//    ec1.setMinClusterSize(1);
//    ec1.setMaxClusterSize(100);
//    ec1.setSearchMethod(tree1);
//    ec1.setInputCloud(normPOints.makeShared());
//    ec1.extract(cluster_indices2);
//
//    std::cout<<"cluster_indices2.size() "<<cluster_indices2.size()<<std::endl;
//
//    if (cluster_indices2.size() < 2) {
//        //    //update map
//        size_t numPrevPlanes = mapPlanes.size();
//        for (size_t i = 0; i < detectedLocalPlanes.size (); i++)
//        {
//            // Check similarity with previous planes detected
//            bool isSamePlane = false;
//            vector<Plane>::iterator itPlane = mapPlanes.begin();
//            for (size_t j = 0; j < numPrevPlanes; j++, itPlane++)
//            {
//                if (areSamePlane(mapPlanes[j], detectedLocalPlanes[i], 0.925, 0.135, 0.135))
//                {
//                    isSamePlane = true;
//                    mergePlanes2(mapPlanes[j], detectedLocalPlanes[i]);
//                    itPlane++;
//
////                for(size_t k = j+1; k < numPrevPlanes; k++, itPlane++)
////                    if (areSamePlane(mapPlanes[j], mapPlanes[k], 0.925, 0.135, 0.135))
////                    {
////                        mergePlanes(mapPlanes[j], mapPlanes[k]);
////                        mapPlanes.erase(itPlane);
////                        --numPrevPlanes;
////                    }
//                    break;
//                }
//            }
//            if(!isSamePlane)
//            {
//                mapPlanes.push_back(detectedLocalPlanes[i]);
//            }
//        }
//        std::cout<<"mapPlanes.size() "<<mapPlanes.size()<<std::endl;
//        //update map
//        return;
//    }
//
////    if (bestMatch.size() < 3)
////        return;
//
//    int allMatchedSize = bestMatch.size();
//
//    if (bestMatchVehicle.size() > 1 && abs(this_kf - this_kf_vehicle) < 4)
//    {
//        allMatchedSize += bestMatchVehicle.size();
//    }
//
//
//    if (bestMatchPole.size() > 1 && abs(this_kf - this_kf_pole) < 4)
//    {
//        allMatchedSize += bestMatchPole.size();
//    }
//
//
//
//
////    std::cout<<"comp time "<<aveTime/(pointSearchInd.size())<<std::endl;
//
//    std::cout<<"allMatchedSize "<<allMatchedSize<<std::endl;
//
//
////KITTI
//    if (allMatchedSize < 7) {
//        //    //update map
//        size_t numPrevPlanes = mapPlanes.size();
//        for (size_t i = 0; i < detectedLocalPlanes.size (); i++)
//        {
//            // Check similarity with previous planes detected
//            bool isSamePlane = false;
//            vector<Plane>::iterator itPlane = mapPlanes.begin();
//            for (size_t j = 0; j < numPrevPlanes; j++, itPlane++)
//            {
//                if (areSamePlane(mapPlanes[j], detectedLocalPlanes[i], 0.925, 0.135, 0.135))
//                {
//                    isSamePlane = true;
//                    mergePlanes2(mapPlanes[j], detectedLocalPlanes[i]);
//                    itPlane++;
//
////                for(size_t k = j+1; k < numPrevPlanes; k++, itPlane++)
////                    if (areSamePlane(mapPlanes[j], mapPlanes[k], 0.925, 0.135, 0.135))
////                    {
////                        mergePlanes(mapPlanes[j], mapPlanes[k]);
////                        mapPlanes.erase(itPlane);
////                        --numPrevPlanes;
////                    }
//                    break;
//                }
//            }
//            if(!isSamePlane)
//            {
//                mapPlanes.push_back(detectedLocalPlanes[i]);
//            }
//        }
//        std::cout<<"mapPlanes.size() "<<mapPlanes.size()<<std::endl;
//        //update map
//        return;
//    }
//
//
//    double icp_score = 0.0;
//
//    double icp_score_t = 0.0;
//
//    //////////////////////////////
////    std::vector<pcl::PointCloud<pcl::PointXYZI>> v_selectedPc;
////    std::vector<Eigen::Vector3d> v_selectedNorm;
////    std::vector<Eigen::Vector3d> v_selectedNormMatch;
//
////    std::vector<double> v_d;
//
////    for (map<unsigned, unsigned>::iterator it = bestMatch.begin(); it != bestMatch.end(); it++)
////    {
////        pcl::PointCloud<pcl::PointXYZI> oriPlanePs;
////        oriPlanePs = *keyframe_vec[this_kf]->vPlanes[it->first].InplanePointCloudOriPtr;
////
////        pcl::VoxelGrid< pcl::PointXYZI > filterTmp;
////        filterTmp.setInputCloud( oriPlanePs.makeShared() );
////        filterTmp.setLeafSize( 1.5, 1.5, 1.5 );
////        filterTmp.filter( oriPlanePs );
//////        v_selectedPc.push_back(oriPlanePs);
////        Eigen::Vector3d selct_n = last_keyframe->vPlanes[it->second].v3normal.cast<double>();
//////        v_selectedNorm.push_back(selct_n);
////
////        Eigen::Vector3d selct_n1 = keyframe_vec[this_kf]->vPlanes[it->first].v3normal.cast<double>();
//////        v_selectedNormMatch.push_back(selct_n1);
//////
//////        v_d.push_back(last_keyframe->vPlanes[it->second].d);
////    }
//
//    std::vector<Eigen::Vector3d> v_centriods;
//    std::vector<Eigen::Vector3d> v_centriodsMatch;
//
//    if (bestMatchVehicle.size() > 1 && abs(this_kf - this_kf_vehicle) < 2)
//    {
//        for (map<unsigned, unsigned>::iterator it = bestMatchVehicle.begin(); it != bestMatchVehicle.end(); it++)
//        {
//            Eigen::Vector3d selct_n = last_keyframe->vVehicles[it->second].v3center.cast<double>();
//            v_centriods.push_back(selct_n);
//
//            Eigen::Vector3d selct_n1 = keyframe_vec[this_kf_vehicle]->vVehicles[it->first].v3center.cast<double>();
//            v_centriodsMatch.push_back(selct_n1);
//        }
//    }
//
//
//    if (bestMatchPole.size() > 1 && abs(this_kf - this_kf_pole) < 2)
//    {
//        for (map<unsigned, unsigned>::iterator it = bestMatchPole.begin(); it != bestMatchPole.end(); it++)
//        {
//            Eigen::Vector3d selct_n = last_keyframe->vPoles[it->second].v3center.cast<double>();
//            v_centriods.push_back(selct_n);
//
//            Eigen::Vector3d selct_n1 = keyframe_vec[this_kf_pole]->vPoles[it->first].v3center.cast<double>();
//            v_centriodsMatch.push_back(selct_n1);
//
//        }
//    }
//
//    ///////////////////////////////
//
////    laserCloudOri_m2.points.clear();
////    laserCloudOri_m2_1.points.clear();
//
//    pcl::PointCloud<pcl::PointXYZI> laserCloudOri_m2bk;
//
//    for (map<unsigned, unsigned>::iterator it = bestMatch.begin(); it != bestMatch.end(); it++)
//    {
//        laserCloudOri_m2bk = *keyframe_vec[this_kf]->vPlanes[it->first].planePointCloudPtr;
//        for (size_t ii = 0 ; ii < laserCloudOri_m2bk.points.size() ; ++ii)
//        {
//            pcl::PointXYZRGBA tp1;
//            tp1.x = laserCloudOri_m2bk.points[ii].x;
//            tp1.y = laserCloudOri_m2bk.points[ii].y;
//            tp1.z = laserCloudOri_m2bk.points[ii].z;
//            tp1.r = 255.0;
//            tp1.g = 0.0;
//            tp1.b = 0.0;
//            laserCloudOri_m2_1.points.push_back(tp1);
//        }
//
//        laserCloudOri_m2bk = *last_keyframe->vPlanes[it->second].planePointCloudPtr;
//        for (size_t ii = 0 ; ii < laserCloudOri_m2bk.points.size() ; ++ii)
//        {
//            pcl::PointXYZRGBA tp1;
//            tp1.x = laserCloudOri_m2bk.points[ii].x;
//            tp1.y = laserCloudOri_m2bk.points[ii].y;
//            tp1.z = laserCloudOri_m2bk.points[ii].z;
//            tp1.r = 255.0;
//            tp1.g = 255.0;
//            tp1.b = 0.0;
//            laserCloudOri_m2_1.points.push_back(tp1);
//        }
//
//
//        laserCloudOri_m2 += *keyframe_vec[this_kf]->vPlanes[it->first].planePointCloudPtr;
//        laserCloudOri_m2 += *last_keyframe->vPlanes[it->second].planePointCloudPtr;
//    }
//
//    for (map<unsigned, unsigned>::iterator it = bestMatchVehicle.begin(); it != bestMatchVehicle.end(); it++)
//    {
//        laserCloudOri_m2bk = *keyframe_vec[this_kf_vehicle]->vVehicles[it->first].VehiclePointCloudPtr;
//        for (size_t ii = 0 ; ii < laserCloudOri_m2bk.points.size() ; ++ii)
//        {
//            pcl::PointXYZRGBA tp1;
//            tp1.x = laserCloudOri_m2bk.points[ii].x;
//            tp1.y = laserCloudOri_m2bk.points[ii].y;
//            tp1.z = laserCloudOri_m2bk.points[ii].z;
//            tp1.r = 0.0;
//            tp1.g = 255.0;
//            tp1.b = 0.0;
//            laserCloudOri_m2_1.points.push_back(tp1);
//        }
//
//        laserCloudOri_m2bk = *last_keyframe->vVehicles[it->second].VehiclePointCloudPtr;
//        for (size_t ii = 0 ; ii < laserCloudOri_m2bk.points.size() ; ++ii)
//        {
//            pcl::PointXYZRGBA tp1;
//            tp1.x = laserCloudOri_m2bk.points[ii].x;
//            tp1.y = laserCloudOri_m2bk.points[ii].y;
//            tp1.z = laserCloudOri_m2bk.points[ii].z;
//            tp1.r = 255.0;
//            tp1.g = 255.0;
//            tp1.b = 0.0;
//            laserCloudOri_m2_1.points.push_back(tp1);
//        }
//
//
////        laserCloudOri_m2 += *keyframe_vec[this_kf_vehicle]->vVehicles[it->first].VehiclePointCloudPtr;
////        laserCloudOri_m2 += *last_keyframe->vVehicles[it->second].VehiclePointCloudPtr;
//    }
//
//    for (map<unsigned, unsigned>::iterator it = bestMatchPole.begin(); it != bestMatchPole.end(); it++)
//    {
//        laserCloudOri_m2bk = *keyframe_vec[this_kf_pole]->vPoles[it->first].PolePointCloudPtr;
//        for (size_t ii = 0 ; ii < laserCloudOri_m2bk.points.size() ; ++ii)
//
//        {
//            pcl::PointXYZRGBA tp1;
//            tp1.x = laserCloudOri_m2bk.points[ii].x;
//            tp1.y = laserCloudOri_m2bk.points[ii].y;
//            tp1.z = laserCloudOri_m2bk.points[ii].z;
//            tp1.r = 0.0;
//            tp1.g = 0.0;
//            tp1.b = 255.0;
//            laserCloudOri_m2_1.points.push_back(tp1);
//        }
//
//        laserCloudOri_m2bk = *last_keyframe->vPoles[it->second].PolePointCloudPtr;
//        for (size_t ii = 0 ; ii < laserCloudOri_m2bk.points.size() ; ++ii)
//        {
//            pcl::PointXYZRGBA tp1;
//            tp1.x = laserCloudOri_m2bk.points[ii].x;
//            tp1.y = laserCloudOri_m2bk.points[ii].y;
//            tp1.z = laserCloudOri_m2bk.points[ii].z;
//            tp1.r = 255.0;
//            tp1.g = 255.0;
//            tp1.b = 0.0;
//            laserCloudOri_m2_1.points.push_back(tp1);
//        }
//
////        laserCloudOri_m2 += *keyframe_vec[this_kf_pole]->vPoles[it->first].PolePointCloudPtr;
////        laserCloudOri_m2 += *last_keyframe->vPoles[it->second].PolePointCloudPtr;
//    }
//
////    laserCloudOri_m2.clear();
////
////    laserCloudOri_m2 += keyframe_vec[this_kf]->m_accumulated_surf_pc;
////    laserCloudOri_m2 += last_keyframe->m_accumulated_surf_pc;
//
//
////    Eigen::Matrix<float, 4, 4> transform;
////    transformationfromMatches(v_centriods, v_centriodsMatch, &transform);
//
//
//    //////////////////////////////
//
//    Eigen::Quaterniond quaternion(1, 0, 0, 0);
//    Eigen::Vector3d    trans(0,0,0);
//
//
//    double init_cost, final_cost;
//
//    /////////////////////////////////
//    double time_begMapAlign = pcl::getTime();
//
////    if (v_selectedNorm.size() > 3)
////        scene_align.find_init_tranfrom_of_two_mappings(v_selectedNorm, v_selectedNormMatch, quaternion);
//
//    if (v_centriods.size() > 3) {
//
//        Eigen::Matrix<float, 4, 4> transform;
//
////        transformationfromMatches(v_centriods, v_centriodsMatch, &transform, trans);
//
////        transformationfromMatches(v_centriodsMatch, v_centriods, &transform, trans);
//
//
//        scene_align.find_init_tranfrom_of_two_mappings2(v_centriods, v_centriodsMatch, trans);
//
//    }
//
////    pcl::PointCloud<pcl::PointXYZI> laserCloudOri_m2tf;
//
////    for (size_t pi = 0 ; pi < keyframe_vec[this_kf]->m_accumulated_surf_pc.points.size() ; ++pi)
////    {
////        pcl::PointXYZI pt;
////        pt.x = keyframe_vec[this_kf]->m_accumulated_surf_pc.points[pi].x + trans(0);
////        pt.y = keyframe_vec[this_kf]->m_accumulated_surf_pc.points[pi].y + trans(1);
////        pt.z = keyframe_vec[this_kf]->m_accumulated_surf_pc.points[pi].z + trans(2);
//////        pt.intensity = keyframe_vec[this_kf]->m_accumulated_surf_pc.points[pi].intensity;
////        pt.intensity = 0.5;
////        laserCloudOri_m2tf.push_back(pt);
////    }
//
////    laserCloudOri_m2 += laserCloudOri_m2tf;
//
//
//
////    for (map<unsigned, unsigned>::iterator it = bestMatchVehicle.begin(); it != bestMatchVehicle.end(); it++)
////    {
////        laserCloudOri_m2bk = *keyframe_vec[this_kf_vehicle]->vVehicles[it->first].VehiclePointCloudPtr;
////        for (size_t ii = 0 ; ii < laserCloudOri_m2bk.points.size() ; ++ii)
////        {
////            pcl::PointXYZI tp1;
////            tp1.x = laserCloudOri_m2bk.points[ii].x + trans(0);
////            tp1.y = laserCloudOri_m2bk.points[ii].y + trans(1);
////            tp1.z = laserCloudOri_m2bk.points[ii].z + trans(2);
////            tp1.intensity = 0.5;
////            laserCloudOri_m2tf.push_back(tp1);
////        }
////    }
////
////    for (map<unsigned, unsigned>::iterator it = bestMatchPole.begin(); it != bestMatchPole.end(); it++)
////    {
////        laserCloudOri_m2bk = *keyframe_vec[this_kf_pole]->vPoles[it->first].PolePointCloudPtr;
////        for (size_t ii = 0 ; ii < laserCloudOri_m2bk.points.size() ; ++ii)
////        {
////            pcl::PointXYZI tp1;
////            tp1.x = laserCloudOri_m2bk.points[ii].x + trans(0);
////            tp1.y = laserCloudOri_m2bk.points[ii].y + trans(1);
////            tp1.z = laserCloudOri_m2bk.points[ii].z + trans(2);
////            tp1.intensity = 0.5;
////            laserCloudOri_m2tf.push_back(tp1);
////        }
////    }
////
////    laserCloudOri_m2 += laserCloudOri_m2tf;
//
//
//    /************/
////    std::cout<<"====test===="<<std::endl;
////    std::cout<<keyframe_vec[this_kf]->m_accumulated_point_cloud.size()<<"  "<<keyframe_vec[this_kf]->m_accumulated_ng_pc.size()<<std::endl;
////    std::cout<<float(keyframe_vec[this_kf]->m_accumulated_point_cloud.size())/float(keyframe_vec[this_kf]->m_accumulated_ng_pc.size())<<std::endl;
////
////    scene_align.find_tranfrom_of_two_mappings(keyframe_vec[this_kf]->m_accumulated_point_cloud, last_keyframe->m_accumulated_point_cloud, icp_score_t);
////    scene_align.find_tranfrom_of_two_mappings(keyframe_vec[this_kf]->m_accumulated_ng_pc, last_keyframe->m_accumulated_ng_pc, icp_score_t);
////    std::cout<<"====test===="<<std::endl;
//    /************/
//
////    cout<<"semantic ICP: "<<std::endl;
////
////    scene_align.find_tranfrom_of_two_mappings(keyframe_vec[this_kf]->m_accumulated_g_pc, last_keyframe->m_accumulated_g_pc,
////                                  keyframe_vec[this_kf]->m_accumulated_structure_pc, last_keyframe->m_accumulated_structure_pc,
////                                  keyframe_vec[this_kf]->m_accumulated_vehicle_pc, last_keyframe->m_accumulated_vehicle_pc,
////                                  icp_score, quaternion, trans,
////                                  init_cost, final_cost);
////
////    std::cout<<icp_score<<"  "<<init_cost<<"  "<<final_cost<<std::endl;
//
//
//    scene_align.find_tranfrom_of_two_mappings(keyframe_vec[this_kf]->m_accumulated_surf_pc, keyframe_vec[this_kf]->m_accumulated_line_pc,
//                                              last_keyframe->m_accumulated_surf_pc, last_keyframe->m_accumulated_line_pc,
//                                              icp_score, quaternion, trans, init_cost, final_cost);
//
//
////    scene_align.find_tranfrom_of_two_mappings(keyframe_vec[this_kf]->m_accumulated_surf_pc, keyframe_vec[this_kf]->m_accumulated_line_pc,
////                                       last_keyframe->m_accumulated_surf_pc, last_keyframe->m_accumulated_line_pc,
////                                       icp_score, v_selectedPc, v_selectedNorm, v_d, quaternion, trans, init_cost, final_cost);
//
//
//
//    double time_endMapAlign = pcl::getTime();
//
////    std::cout<<"align time "<<time_endMapAlign-time_begMapAlign<<std::endl;
///////////////////////////////
//
//    std::cout<<icp_score<<"  "<<init_cost<<"  "<<final_cost<<std::endl;
//
//    printf("ICP inlier threshold = %lf\r\n", icp_score);
//
//    auto Q_a = pose3d_vec[this_kf].q;
//    auto Q_b = pose3d_vec[pose3d_vec.size() - 1].q;
//    auto T_a = pose3d_vec[this_kf].p;
//    auto T_b = pose3d_vec[pose3d_vec.size() - 1].p;
//    auto ICP_q = scene_align.m_q_w_curr;
//    auto ICP_t = scene_align.m_t_w_curr;
//
//    ICP_t = ( ICP_q.inverse() * ( -ICP_t ) );
//    ICP_q = ICP_q.inverse();
//
//    std::cout << "ICP_q = " << ICP_q.coeffs().transpose() << std::endl;
//    std::cout << "ICP_t = " << ICP_t.transpose() << std::endl;
//
//    //KITTI
////    if ( icp_score < 0.31 )
////    if ( icp_score < 0.35 )
//    if ( icp_score < 0.33 && final_cost > 50.0)
//    {
//
//        v_icp.push_back(icp_score_t);
//
//        double t_s = 0.0;
//        for (auto item : v_icp)
//        {
//            t_s += item;
//        }
//
//        std::cout<<"t_s ave: "<<t_s/v_icp.size()<<std::endl;
//
////        laserCloudOri_m2.points.clear();
////        laserCloudOri_m2_1.points.clear();
////        pcl::PointCloud<pcl::PointXYZI> laserCloudOri_m2bk;
////
////        for (map<unsigned, unsigned>::iterator it = bestMatch.begin(); it != bestMatch.end(); it++)
////        {
////            laserCloudOri_m2bk = *keyframe_vec[this_kf]->vPlanes[it->first].planePointCloudPtr;
////            for (size_t ii = 0 ; ii < laserCloudOri_m2bk.points.size() ; ++ii)
////            {
////                pcl::PointXYZRGBA tp1;
////                tp1.x = laserCloudOri_m2bk.points[ii].x;
////                tp1.y = laserCloudOri_m2bk.points[ii].y;
////                tp1.z = laserCloudOri_m2bk.points[ii].z;
////                tp1.r = 255.0;
////                tp1.g = 0.0;
////                tp1.b = 0.0;
////                laserCloudOri_m2_1.points.push_back(tp1);
////            }
////
////            laserCloudOri_m2bk = *last_keyframe->vPlanes[it->second].planePointCloudPtr;
////            for (size_t ii = 0 ; ii < laserCloudOri_m2bk.points.size() ; ++ii)
////            {
////                pcl::PointXYZRGBA tp1;
////                tp1.x = laserCloudOri_m2bk.points[ii].x;
////                tp1.y = laserCloudOri_m2bk.points[ii].y;
////                tp1.z = laserCloudOri_m2bk.points[ii].z;
////                tp1.r = 255.0;
////                tp1.g = 255.0;
////                tp1.b = 0.0;
////                laserCloudOri_m2_1.points.push_back(tp1);
////            }
////
////
////            laserCloudOri_m2 += *keyframe_vec[this_kf]->vPlanes[it->first].planePointCloudPtr;
////            laserCloudOri_m2 += *last_keyframe->vPlanes[it->second].planePointCloudPtr;
////        }
////
////        for (map<unsigned, unsigned>::iterator it = bestMatchVehicle.begin(); it != bestMatchVehicle.end(); it++)
////        {
////            laserCloudOri_m2bk = *keyframe_vec[this_kf_vehicle]->vVehicles[it->first].VehiclePointCloudPtr;
////            for (size_t ii = 0 ; ii < laserCloudOri_m2bk.points.size() ; ++ii)
////            {
////                pcl::PointXYZRGBA tp1;
////                tp1.x = laserCloudOri_m2bk.points[ii].x;
////                tp1.y = laserCloudOri_m2bk.points[ii].y;
////                tp1.z = laserCloudOri_m2bk.points[ii].z;
////                tp1.r = 0.0;
////                tp1.g = 255.0;
////                tp1.b = 0.0;
////                laserCloudOri_m2_1.points.push_back(tp1);
////            }
////
////            laserCloudOri_m2bk = *last_keyframe->vVehicles[it->second].VehiclePointCloudPtr;
////            for (size_t ii = 0 ; ii < laserCloudOri_m2bk.points.size() ; ++ii)
////            {
////                pcl::PointXYZRGBA tp1;
////                tp1.x = laserCloudOri_m2bk.points[ii].x;
////                tp1.y = laserCloudOri_m2bk.points[ii].y;
////                tp1.z = laserCloudOri_m2bk.points[ii].z;
////                tp1.r = 255.0;
////                tp1.g = 255.0;
////                tp1.b = 0.0;
////                laserCloudOri_m2_1.points.push_back(tp1);
////            }
////
////
////            laserCloudOri_m2 += *keyframe_vec[this_kf_vehicle]->vVehicles[it->first].VehiclePointCloudPtr;
////            laserCloudOri_m2 += *last_keyframe->vVehicles[it->second].VehiclePointCloudPtr;
////        }
////
////        for (map<unsigned, unsigned>::iterator it = bestMatchPole.begin(); it != bestMatchPole.end(); it++)
////        {
////            laserCloudOri_m2bk = *keyframe_vec[this_kf_pole]->vPoles[it->first].PolePointCloudPtr;
////            for (size_t ii = 0 ; ii < laserCloudOri_m2bk.points.size() ; ++ii)
////
////            {
////                pcl::PointXYZRGBA tp1;
////                tp1.x = laserCloudOri_m2bk.points[ii].x;
////                tp1.y = laserCloudOri_m2bk.points[ii].y;
////                tp1.z = laserCloudOri_m2bk.points[ii].z;
////                tp1.r = 0.0;
////                tp1.g = 0.0;
////                tp1.b = 255.0;
////                laserCloudOri_m2_1.points.push_back(tp1);
////            }
////
////            laserCloudOri_m2bk = *last_keyframe->vPoles[it->second].PolePointCloudPtr;
////            for (size_t ii = 0 ; ii < laserCloudOri_m2bk.points.size() ; ++ii)
////            {
////                pcl::PointXYZRGBA tp1;
////                tp1.x = laserCloudOri_m2bk.points[ii].x;
////                tp1.y = laserCloudOri_m2bk.points[ii].y;
////                tp1.z = laserCloudOri_m2bk.points[ii].z;
////                tp1.r = 255.0;
////                tp1.g = 255.0;
////                tp1.b = 0.0;
////                laserCloudOri_m2_1.points.push_back(tp1);
////            }
////
////            laserCloudOri_m2 += *keyframe_vec[this_kf_pole]->vPoles[it->first].PolePointCloudPtr;
////            laserCloudOri_m2 += *last_keyframe->vPoles[it->second].PolePointCloudPtr;
////        }
//
////        std::cout<<"save !!"<<std::endl;
////        laserCloudOri_m2_1.width = 1;
////        laserCloudOri_m2_1.height = laserCloudOri_m2_1.points.size();
////
////        std::string pathsave = string("/home/jjwen/software/catkin_rangenet_ws/src/") +  to_string(keyFrameCount) + ".pcd";
////
////        pcl::io::savePCDFileASCII (pathsave, laserCloudOri_m2_1); //将点云保存到PCD文件中
//
//
//        std::cout<<"bestMatchVehicle.size() "<<bestMatchVehicle.size()<<std::endl;
//        std::cout<<"last_keyframe->vVehicles.size() "<<last_keyframe->vVehicles.size()<<std::endl;
//        std::cout<<"keyframe_vec[this_kf_vehicle]->vVehicles.size() "<<keyframe_vec[this_kf_vehicle]->vVehicles.size()<<std::endl;
//
//
//        printf("I believe this is true loop.\r\n");
//
//        VectorOfConstraints constrain_vec_temp;
//        constrain_vec_temp = constrain_vec;
//
//        /*闭环约束*/
//        Constraint3d pose_constrain;
//        auto q_res = Q_b.inverse() * ICP_q.inverse() * Q_a;
//        //q_res = q_res.inverse();
//        auto t_res = Q_b.inverse() * ( ICP_q.inverse() * ( T_a - ICP_t ) - T_b );
//        //t_res = q_res.inverse()*(-t_res);
//        //q_res = q_res.inverse();
//
////                cout << "=== Add_constrain_of_loop ====" << endl;
////                cout << Q_a.coeffs().transpose() << endl;
////                cout << Q_b.coeffs().transpose() << endl;
////                cout << ICP_q.coeffs().transpose() << endl;
////                cout << T_a.transpose() << endl;
////                cout << T_b.transpose() << endl;
////                cout << ICP_t.transpose() << endl;
////                cout << "Result: " << endl;
////                cout << q_res.coeffs().transpose() << endl;
////                cout << t_res.transpose() << endl;
//
//        //t_res.setZero();
//        pose_constrain.id_begin = pose3d_vec.size() - 1;
//        pose_constrain.id_end = this_kf;
//        pose_constrain.t_be.p = t_res;
//        pose_constrain.t_be.q = q_res;
//        /*闭环约束*/
//
//
//        loop_closure_matchedid[pose3d_vec.size() - 1] = this_kf;
//
//        constrain_vec_temp.push_back( pose_constrain );
//
//
//        pose3d_map_ori = pose3d_map;
//        auto temp_pose_3d_map = pose3d_map;
//
//        pose_graph_optimization(temp_pose_3d_map, constrain_vec_temp);
//
//        optimized_pose3d_map = temp_pose_3d_map;
//
//        ////////
//
////        constrain_vec = constrain_vec_temp;
////        pose3d_map = temp_pose_3d_map;
//
//        ////////
//
//        OutputPoses( std::string("/home/jjwen/result/poses_ori.txt" ), pose3d_map_ori );
//        OutputPoses( std::string( "/home/jjwen/result/poses_opm.txt" ), temp_pose_3d_map );
//
//
////        refined_pt = map_rfn.refine_pointcloud( map_id_pc, pose3d_map_ori, temp_pose_3d_map, ( int ) map_id_pc.size() - 1);
//
//        refined_pt.points.clear();
//        refined_pt_bef.points.clear();
//
//        for ( int pc_idx = ( int ) map_id_pc.size() - 1; pc_idx >= 0; pc_idx -= 2 )
//        {
////            std::cout << "*** Refine pointcloud, curren idx = " << pc_idx << " ***" << endl;
//            refined_pt += map_rfn.refine_pointcloud( map_id_pc, pose3d_map_ori, temp_pose_3d_map, pc_idx);
//
//            refined_pt_bef += map_rfn.refine_pointcloud( map_id_pc, pose3d_map_ori, pose3d_map_ori, pc_idx);
//
//
//        }
//        //map_rfn.refine_mapping( path_name, 0 );
//        if ( 0 )
//        {
//            map_rfn.refine_mapping( map_id_pc, pose3d_map_ori, temp_pose_3d_map);
////            map_rfn.m_pts_aft_refind
//        }
//
//
//
//
//        //    //update map
//        size_t numPrevPlanes = mapPlanes.size();
//        for (size_t i = 0; i < detectedLocalPlanes.size (); i++)
//        {
//            // Check similarity with previous planes detected
//            bool isSamePlane = false;
//            vector<Plane>::iterator itPlane = mapPlanes.begin();
//            for (size_t j = 0; j < numPrevPlanes; j++, itPlane++)
//            {
//                if (areSamePlane(mapPlanes[j], detectedLocalPlanes[i], 0.925, 0.135, 0.135))
//                {
//                    isSamePlane = true;
//                    mergePlanes2(mapPlanes[j], detectedLocalPlanes[i]);
//                    itPlane++;
//
////                for(size_t k = j+1; k < numPrevPlanes; k++, itPlane++)
////                    if (areSamePlane(mapPlanes[j], mapPlanes[k], 0.925, 0.135, 0.135))
////                    {
////                        mergePlanes(mapPlanes[j], mapPlanes[k]);
////                        mapPlanes.erase(itPlane);
////                        --numPrevPlanes;
////                    }
//                    break;
//                }
//            }
//            if(!isSamePlane)
//            {
//                mapPlanes.push_back(detectedLocalPlanes[i]);
//            }
//        }
//        std::cout<<"mapPlanes.size() "<<mapPlanes.size()<<std::endl;
//        //update map
//
//
//
//
//
//    }
//    else
//    {
//        //    //update map
//        size_t numPrevPlanes = mapPlanes.size();
//        for (size_t i = 0; i < detectedLocalPlanes.size (); i++)
//        {
//            // Check similarity with previous planes detected
//            bool isSamePlane = false;
//            vector<Plane>::iterator itPlane = mapPlanes.begin();
//            for (size_t j = 0; j < numPrevPlanes; j++, itPlane++)
//            {
//                if (areSamePlane(mapPlanes[j], detectedLocalPlanes[i], 0.925, 0.135, 0.135))
//                {
//                    isSamePlane = true;
//                    mergePlanes2(mapPlanes[j], detectedLocalPlanes[i]);
//                    itPlane++;
//
////                for(size_t k = j+1; k < numPrevPlanes; k++, itPlane++)
////                    if (areSamePlane(mapPlanes[j], mapPlanes[k], 0.925, 0.135, 0.135))
////                    {
////                        mergePlanes(mapPlanes[j], mapPlanes[k]);
////                        mapPlanes.erase(itPlane);
////                        --numPrevPlanes;
////                    }
//                    break;
//                }
//            }
//            if(!isSamePlane)
//            {
//                mapPlanes.push_back(detectedLocalPlanes[i]);
//            }
//        }
//        std::cout<<"mapPlanes.size() "<<mapPlanes.size()<<std::endl;
//        //update map
//    }
//
//}



void LiPMatch::run()
{
    size_t numPrevKFs = 0;

    while(!LiPMatch_stop)  // Stop loop if LiPMatch
    {
        if( numPrevKFs == frameQueue.size() )
        {
          sleep(10);
        }
        else
        {
            detectPlanesCloud( frameQueue[numPrevKFs], numPrevKFs);
            ++numPrevKFs;
        }
    }
    LiPMatch_finished = true;
}



bool LiPMatch::stop_LiPMatch()
{
    LiPMatch_stop = true;
    while(!LiPMatch_finished)
        sleep(1);

    cout << "Waiting for LiPMatch thread to die.." << endl;

    joinThread(LiPMatch_hd);
    LiPMatch_hd.clear();

    return true;
}

LiPMatch::~LiPMatch()
{
    cout << "\n\n\nLiPMatch destructor called -> Save color information to file\n";

    stop_LiPMatch();

    cout << " .. LiPMatch has died." << endl;
}









//#include <LiPMatch.h>
//
//using namespace std;
//using namespace Eigen;
//using namespace LiPMatch_ns;
//
//
//LiPMatch::LiPMatch() : LiPMatch_stop(false), LiPMatch_finished(false)
//{
//    LiPMatch_hd = createThreadFromObjectMethod(this,&LiPMatch::run);
//
//    keyframe_vec.clear();
//
//    all_kfs_pose.points.clear();
//
//    map_rfn.set_down_sample_resolution( 0.75 );
//}
//
//
//
//void LiPMatch::detectPlanesCloud( m_keyframe &c_keyframe, int keyFrameCount)
//{
////    static std::ofstream unarycout("/home/jjwen/u.txt");
////    static std::ofstream binarycout("/home/jjwen/b.txt");
//
//    static pcl::VoxelGrid<pcl::PointXYZI> grid_1;
//    grid_1.setLeafSize(0.2,0.2,0.2);
////    grid_1.setInputCloud(c_keyframe.orilaserCloud);
////    grid_1.filter (*c_keyframe.orilaserCloud);
//
//    grid_1.setInputCloud(c_keyframe.structurelaserCloud);
//    grid_1.filter (*c_keyframe.structurelaserCloud);
//
//    grid_1.setInputCloud(c_keyframe.vehiclelaserCloud);
//    grid_1.filter (*c_keyframe.vehiclelaserCloud);
//
//    grid_1.setInputCloud(c_keyframe.naturelaserCloud);
//    grid_1.filter (*c_keyframe.naturelaserCloud);
//
////    grid_1.setInputCloud(c_keyframe.objectlaserCloud);
////    grid_1.filter (*c_keyframe.objectlaserCloud);
//
//    static pcl::VoxelGrid<pcl::PointXYZI> grid_2;
//    grid_2.setLeafSize(0.8,0.8,0.8);
//    grid_2.setInputCloud(c_keyframe.surflaserCloud);
//    grid_2.filter (*c_keyframe.surflaserCloud);
//
//    static pcl::VoxelGrid<pcl::PointXYZI> grid_3;
//    grid_3.setLeafSize(0.4,0.4,0.4);
//    grid_3.setInputCloud(c_keyframe.linelaserCloud);
//    grid_3.filter (*c_keyframe.linelaserCloud);
//
//    grid_3.setInputCloud(c_keyframe.orilaserCloud);
//    grid_3.filter (*c_keyframe.orilaserCloud);
//
//    grid_3.setInputCloud(c_keyframe.g_laserCloud.makeShared());
//    grid_3.filter (c_keyframe.g_laserCloud);
//
//    double time_behinSeg = pcl::getTime();
//
//    //////////////////////
//    int colorid = 0;
//    //聚类
//    pcl::search::KdTree<pcl::PointXYZI>::Ptr treeVehicle (new pcl::search::KdTree<pcl::PointXYZI>);
//    treeVehicle->setInputCloud (c_keyframe.vehiclelaserCloud);
//    std::vector<pcl::PointIndices> cluster_indices_vehicle;
//    pcl::EuclideanClusterExtraction<pcl::PointXYZI> ec_vehicle;
//    ec_vehicle.setClusterTolerance (0.25);
////    ec.setMinClusterSize (100);
//    ec_vehicle.setMinClusterSize (300);
//    ec_vehicle.setMaxClusterSize (150000);
//    ec_vehicle.setSearchMethod (treeVehicle);
//    ec_vehicle.setInputCloud (c_keyframe.vehiclelaserCloud);
//    ec_vehicle.extract (cluster_indices_vehicle);
//    pcl::PointCloud<pcl::PointXYZI>::Ptr laserCloudNgAftEe_vehicles(new pcl::PointCloud<pcl::PointXYZI>());
//    pcl::PCA< pcl::PointXYZI > pca;
//
//    vector<Vehicle> detectedLocalVehicles;
//
//    for (std::vector<pcl::PointIndices>::const_iterator it = cluster_indices_vehicle.begin (); it != cluster_indices_vehicle.end (); ++it)
//    {
//        pcl::PointCloud<pcl::PointXYZI>::Ptr laserCloudNgAftEe_vehicle(new pcl::PointCloud<pcl::PointXYZI>());
//        for (std::vector<int>::const_iterator pit = it->indices.begin (); pit != it->indices.end (); ++pit)
//        {
//            c_keyframe.vehiclelaserCloud->points[*pit].intensity = colorid;
//            laserCloudNgAftEe_vehicle->points.push_back (c_keyframe.vehiclelaserCloud->points[*pit]);
//        }
//        pca.setInputCloud(laserCloudNgAftEe_vehicle);
//        Eigen::VectorXf eigenVal = pca.getEigenValues();
//
//        if (eigenVal[2] / eigenVal[0] < 0.005)
//            continue;
//
//        *laserCloudNgAftEe_vehicles += *laserCloudNgAftEe_vehicle;
//
//        colorid++;
//
////        std::cout<<eigenVal[0]<<" "<<eigenVal[1]<<" "<<eigenVal[2]<<std::endl;
//
//        Vehicle vc;
//        vc.VehiclePointCloudPtr = laserCloudNgAftEe_vehicle;
//        vc.keyFrameId = keyFrameCount;
//        vc.calcCenterAndElongation();
//
//        detectedLocalVehicles.push_back(vc);
//
//    }
//
//    laserCloudOri_mp1 += *laserCloudNgAftEe_vehicles;
//
//    observedVehicles.clear();
//    vVehicles.clear();
//
//    for (size_t i = 0; i < detectedLocalVehicles.size (); i++)
//    {
//        detectedLocalVehicles[i].id = vVehicles.size();
//
//        // Update co-visibility graph
//        for(set<unsigned>::iterator it = observedVehicles.begin(); it != observedVehicles.end(); it++)
//        {
//            detectedLocalVehicles[i].neighborVehicles[*it] = 1;
//            vVehicles[*it].neighborVehicles[detectedLocalVehicles[i].id] = 1;
//        }
//        observedVehicles.insert(detectedLocalVehicles[i].id);
//        vVehicles.push_back(detectedLocalVehicles[i]);
//    }
//
//
//    std::shared_ptr<Maps_keyframe<float>> mk = std::make_shared<Maps_keyframe<float>>();
//
//    std::cout<<"vVehicles.size() "<<vVehicles.size()<<std::endl;
//
//    mk->vVehicles = vVehicles;
//
//    //聚类
//    pcl::search::KdTree<pcl::PointXYZI>::Ptr treeNature (new pcl::search::KdTree<pcl::PointXYZI>);
//    treeNature->setInputCloud (c_keyframe.naturelaserCloud);
//    std::vector<pcl::PointIndices> cluster_indices_nature;
//    pcl::EuclideanClusterExtraction<pcl::PointXYZI> ec_nature;
//    ec_nature.setClusterTolerance (0.25);
////    ec.setMinClusterSize (100);
//    ec_nature.setMinClusterSize (60);
//    ec_nature.setMaxClusterSize (150000);
//    ec_nature.setSearchMethod (treeNature);
//    ec_nature.setInputCloud (c_keyframe.naturelaserCloud);
//    ec_nature.extract (cluster_indices_nature);
//    pcl::PointCloud<pcl::PointXYZI>::Ptr laserCloudNgAftEe_natures(new pcl::PointCloud<pcl::PointXYZI>());
//    pcl::PCA< pcl::PointXYZI > pca1;
//
//    vector<Pole> detectedLocalPoles;
//
//    colorid = 0;
//    for (std::vector<pcl::PointIndices>::const_iterator it = cluster_indices_nature.begin (); it != cluster_indices_nature.end (); ++it)
//    {
//        pcl::PointCloud<pcl::PointXYZI>::Ptr laserCloudNgAftEe_nature(new pcl::PointCloud<pcl::PointXYZI>());
//        for (std::vector<int>::const_iterator pit = it->indices.begin (); pit != it->indices.end (); ++pit)
//        {
//            c_keyframe.naturelaserCloud->points[*pit].intensity = colorid;
//            laserCloudNgAftEe_nature->points.push_back (c_keyframe.naturelaserCloud->points[*pit]);
//        }
//        pca1.setInputCloud(laserCloudNgAftEe_nature);
//        Eigen::VectorXf eigenVal = pca1.getEigenValues();
//
//        if (eigenVal[1] / eigenVal[0] > 0.17)
//            continue;
//
//        *laserCloudNgAftEe_natures += *laserCloudNgAftEe_nature;
//        colorid++;
//
//        Pole vc;
//        vc.PolePointCloudPtr = laserCloudNgAftEe_nature;
//        vc.keyFrameId = keyFrameCount;
//        vc.calcCenterAndElongation();
//
//        detectedLocalPoles.push_back(vc);
//
////        std::cout<<eigenVal[0]<<" "<<eigenVal[1]<<" "<<eigenVal[2]<<std::endl;
//
//    }
//
//    laserCloudOri_mp1 += *laserCloudNgAftEe_natures;
//
//    observedPoles.clear();
//    vPoles.clear();
//
//    for (size_t i = 0; i < detectedLocalPoles.size (); i++)
//    {
//        detectedLocalPoles[i].id = vPoles.size();
//
//        // Update co-visibility graph
//        for(set<unsigned>::iterator it = observedPoles.begin(); it != observedPoles.end(); it++)
//        {
//            detectedLocalPoles[i].neighborPoles[*it] = 1;
//            vPoles[*it].neighborPoles[detectedLocalPoles[i].id] = 1;
//        }
//        observedPoles.insert(detectedLocalPoles[i].id);
//        vPoles.push_back(detectedLocalPoles[i]);
//    }
//
//    std::cout<<"vPoles.size() "<<vPoles.size()<<std::endl;
//
//    mk->vPoles = vPoles;
//
//
//
//    /////////////////////
//
//
//
//    //聚类
//    pcl::search::KdTree<pcl::PointXYZI>::Ptr tree (new pcl::search::KdTree<pcl::PointXYZI>);
//    tree->setInputCloud (c_keyframe.structurelaserCloud);
//    std::vector<pcl::PointIndices> cluster_indices;
//    pcl::EuclideanClusterExtraction<pcl::PointXYZI> ec;
//    ec.setClusterTolerance (0.25);
////    ec.setMinClusterSize (100);
//    ec.setMinClusterSize (400);
//    ec.setMaxClusterSize (150000);
//    ec.setSearchMethod (tree);
//    ec.setInputCloud (c_keyframe.structurelaserCloud);
//    ec.extract (cluster_indices);
//    pcl::PointCloud<pcl::PointXYZI>::Ptr laserCloudNgAftEe(new pcl::PointCloud<pcl::PointXYZI>());
//    for (std::vector<pcl::PointIndices>::const_iterator it = cluster_indices.begin (); it != cluster_indices.end (); ++it)
//    {
//        for (std::vector<int>::const_iterator pit = it->indices.begin (); pit != it->indices.end (); ++pit)
//        {
//            laserCloudNgAftEe->points.push_back (c_keyframe.structurelaserCloud->points[*pit]);
//        }
//    }
//
////    pcl::PointCloud<pcl::PointXYZI>::Ptr laserCloudNgAftEe(new pcl::PointCloud<pcl::PointXYZI>());
////    laserCloudNgAftEe = c_keyframe.structurelaserCloud;
//
//    //区域增长法提取激光点云中的平面
//    pcl::search::Search<pcl::PointXYZI>::Ptr treeRg (new pcl::search::KdTree<pcl::PointXYZI>);
//    pcl::PointCloud <pcl::Normal>::Ptr normals (new pcl::PointCloud <pcl::Normal>);
//    pcl::NormalEstimation<pcl::PointXYZI, pcl::Normal> normal_estimator;
//    normal_estimator.setSearchMethod (treeRg);
//    normal_estimator.setInputCloud (laserCloudNgAftEe);
//    normal_estimator.setKSearch (10);
//    normal_estimator.compute (*normals);
//
//    pcl::RegionGrowing<pcl::PointXYZI, pcl::Normal> reg;
////    reg.setMinClusterSize (100);
//    reg.setMinClusterSize (400);
//    reg.setMaxClusterSize (1000000);
//    reg.setSearchMethod (treeRg);
//    reg.setNumberOfNeighbours (20);
//    reg.setInputCloud (laserCloudNgAftEe);
//    reg.setInputNormals (normals);
//    reg.setSmoothnessThreshold (14.0 / 180.0 * M_PI);
//    reg.setCurvatureThreshold (10.0);
//
//    std::vector <pcl::PointIndices> clusters;
//    reg.extract (clusters);
//
//    pcl::PointCloud<pcl::PointXYZI>::Ptr laserCloudNgAftReg(new pcl::PointCloud<pcl::PointXYZI>());
//    //创建一个模型参数对象，用于记录结果
//    pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients);
//    //inliers表示误差能容忍的点 记录的是点云的序号
//    pcl::PointIndices::Ptr inliers(new pcl::PointIndices);
//    // 创建一个分割器
//    pcl::SACSegmentation<pcl::PointXYZI> seg;
//    // Optional，这个设置可以选定结果平面展示的点是分割掉的点还是分割剩下的点。
//    seg.setOptimizeCoefficients(true);
//    // Mandatory-设置目标几何形状
//    seg.setModelType(pcl::SACMODEL_PLANE);
//    //分割方法：随机采样法
//    seg.setMethodType(pcl::SAC_RANSAC);
//    //设置误差容忍范围，也就是我说过的阈值
//    seg.setDistanceThreshold(0.01);
//
//    vector<Plane> detectedLocalPlanes;
//
//    pcl::PointCloud<pcl::PointXYZI>::Ptr curPlanePoints(new pcl::PointCloud<pcl::PointXYZI>());
//
//    for (size_t i = 0 ; i < clusters.size() ; ++i)
//    {
//        Plane plane;
//        pcl::PointCloud<pcl::PointXYZI>::Ptr pointsOnPlane(new pcl::PointCloud<pcl::PointXYZI>());
//        pointsOnPlane->points.clear();
//
//        for (size_t j = 0 ; j < clusters[i].indices.size() ; ++j)
//        {
//            pcl::PointXYZI tmpPoint;
//            tmpPoint.x = laserCloudNgAftEe->points[clusters[i].indices[j]].x;
//            tmpPoint.y = laserCloudNgAftEe->points[clusters[i].indices[j]].y;
//            tmpPoint.z = laserCloudNgAftEe->points[clusters[i].indices[j]].z;
//            tmpPoint.intensity = i;
//            pointsOnPlane->points.push_back(tmpPoint);
//            laserCloudNgAftReg->points.push_back(tmpPoint);
//        }
//        //输入点云
//        seg.setInputCloud(pointsOnPlane);
//        //分割点云，获得平面和法向量
//        seg.segment(*inliers, *coefficients);
//
//        double planen[4];
//        planen[0] = coefficients->values[0];
//        planen[1] = coefficients->values[1];
//        planen[2] = coefficients->values[2];
//        planen[3] = -1.0 * coefficients->values[3];
//
//        plane.v3normal = Vector3f(planen[0], planen[1], planen[2]);
//        plane.d = planen[3];
//        pcl::copyPointCloud(*pointsOnPlane, *plane.planePointCloudPtr);
//
//        pcl::PointCloud<pcl::PointXYZI>::Ptr laserCloudInlier(new pcl::PointCloud<pcl::PointXYZI>());
//
//        for (std::vector<int>::const_iterator pit = inliers->indices.begin (); pit != inliers->indices.end (); ++pit)
//        {
//            laserCloudInlier->points.push_back (pointsOnPlane->points[*pit]);
//        }
//
//        pcl::copyPointCloud(*laserCloudInlier, *plane.InplanePointCloudOriPtr);
//
//
//        plane.calcConvexHull(plane.planePointCloudPtr,planen);
//
//        plane.computeMassCenterAndArea();
//        plane.areaVoxels= plane.planePointCloudPtr->size() * 0.0025;
//
//        plane.keyFrameId = keyFrameCount;
//
//        *curPlanePoints += *plane.planePointCloudPtr;
//
//        detectedLocalPlanes.push_back(plane);
//    }
//
//    laserCloudOri_mp1 += *curPlanePoints;
//
//
//    static pcl::VoxelGrid<pcl::PointXYZI> grid_t;
//    grid_t.setLeafSize(0.6,0.6,0.6);
//
//    grid_t.setInputCloud(laserCloudOri_mp1.makeShared());
//    grid_t.filter (laserCloudOri_mp1);
//
////    std::cout<<"detectedLocalPlanes.size() "<<detectedLocalPlanes.size ()<<std::endl;
//
//    // Merge detected planes with previous ones if they are the same
//    observedPlanes.clear();
//    vPlanes.clear();
//
//    for (size_t i = 0; i < detectedLocalPlanes.size (); i++)
//    {
//        detectedLocalPlanes[i].id = vPlanes.size();
//
//        // Update co-visibility graph
//        for(set<unsigned>::iterator it = observedPlanes.begin(); it != observedPlanes.end(); it++)
//        {
//            detectedLocalPlanes[i].neighborPlanes[*it] = 1;
//            vPlanes[*it].neighborPlanes[detectedLocalPlanes[i].id] = 1;
//        }
//        observedPlanes.insert(detectedLocalPlanes[i].id);
//        vPlanes.push_back(detectedLocalPlanes[i]);
//    }
//
//    for(set<unsigned>::iterator it = observedPlanes.begin(); it != observedPlanes.end(); it++)
//    {
//        Plane &observedPlane = vPlanes[*it];
//        observedPlane.calcElongationAndPpalDir();
//    }
//
//
//    double time_endinSeg = pcl::getTime();
//
////    std::cout<<"plane seg time: "<<time_endinSeg-time_behinSeg<<std::endl;
//
////    std::shared_ptr<Maps_keyframe<float>> mk = std::make_shared<Maps_keyframe<float>>();
//
//    std::cout<<"vPlanes.size() ";
//    std::cout<<vPlanes.size()<<std::endl;
//
//    mk->vPlanes = vPlanes;
//    mk->m_accumulated_point_cloud = *c_keyframe.orilaserCloud;
//
//    mk->m_accumulated_ng_pc = c_keyframe.g_laserCloud;
//
//    mk->m_keyframe_idx = keyFrameCount;
//    mk->m_ending_frame_idx = c_keyframe.m_ending_frame_idx;
//    mk->m_accumulate_frames = c_keyframe.framecount;
//    mk->m_pose_q = c_keyframe.m_pose_q;
//    mk->m_pose_t = c_keyframe.m_pose_t;
//    mk->m_accumulated_line_pc = *c_keyframe.linelaserCloud;
//    mk->m_accumulated_surf_pc = *c_keyframe.surflaserCloud;
////    mk->m_accumulated_g_pc = c_keyframe.g_laserCloud;
//
//    ////////////////
//
//    Eigen::Quaterniond                                 q_curr;
//    Eigen::Vector3d                                    t_curr;
//
//    q_curr = c_keyframe.m_pose_q;
//    t_curr = c_keyframe.m_pose_t;
//
//    keyframe_vec.push_back( mk );
//
//
//    map_id_pc.insert( std::make_pair( map_id_pc.size(), keyframe_vec.back()->m_accumulated_point_cloud ) );
//
//
//    int curren_frame_idx = keyframe_vec.back()->m_ending_frame_idx;
//
//    pose3d_vec.push_back( Pose3d( q_curr, t_curr ) );
//    pose3d_map.insert( std::make_pair( pose3d_map.size(), Pose3d( q_curr, t_curr ) ) );
//
//    if ( pose3d_vec.size() >= 2 )
//    {
//        Constraint3d temp_csn;
//        Eigen::Vector3d relative_T = pose3d_vec[ pose3d_vec.size() - 2 ].q.inverse() * ( t_curr - pose3d_vec[ pose3d_vec.size() - 2 ].p );
//        Eigen::Quaterniond relative_Q = pose3d_vec[ pose3d_vec.size() - 2 ].q.inverse() * q_curr;
//        temp_csn = Constraint3d( pose3d_vec.size() - 2, pose3d_vec.size() - 1,relative_Q, relative_T );
//        constrain_vec.push_back( temp_csn );
//    }
//
//    std::shared_ptr<Maps_keyframe<float>>& last_keyframe = keyframe_vec.back();
//
//    printf( "--- Current_idx = %d, lidar_frame_idx = %d ---\r\n", keyframe_vec.size(), curren_frame_idx );
//
//    std::map<unsigned, unsigned> bestMatch; bestMatch.clear();
//    int this_kf = 0;
//
//    float wdif_height;
//    float wdif_height2;
//    float wdif_normal;
//    float wrel_dist_centers;
//    float wal;
//    float wea;
//
//
//    pcl::PointXYZI pointSel;
//    pointSel.x = t_curr(0);
//    pointSel.y = t_curr(1);
//    pointSel.z = t_curr(2);
//
//    if (all_kfs_pose.points.size() < 10) {
//        all_kfs_pose.push_back(pointSel);
//        return;
//    }
//
//    m_kdtree_kfs.setInputCloud( all_kfs_pose.makeShared() );
//    std::vector<int> pointSearchInd;
//    std::vector<float> pointSearchSqDis;
//    m_kdtree_kfs.nearestKSearch(pointSel, 10, pointSearchInd, pointSearchSqDis);
//    all_kfs_pose.push_back(pointSel);
//
//    bestMatch.clear();
//    this_kf = 0;
//
//    double aveTime = 0.0;
//    int graphmatchTimes = 0;
//    if (last_keyframe->vPlanes.size() > 2) {
//
//        for (size_t his = 0; his < pointSearchInd.size(); his++) {
//            if ((keyframe_vec.size() - pointSearchInd[his]) <= 10) {
//                continue;
//            }
//
//            if (keyframe_vec[pointSearchInd[his]]->vPlanes.size() < 3)
//                continue;
//
//            Subgraph currentSubgraph(keyframe_vec[pointSearchInd[his]]->vPlanes, 0);
//            Subgraph targetSubgraph(last_keyframe->vPlanes, 0);
//
//            int unaycount;
//            double time_begComp = pcl::getTime();
//            std::map<unsigned, unsigned> resultingMatch = matcher.compareSubgraphs(currentSubgraph, targetSubgraph,
//                                                                                   unaycount);
//
//            graphmatchTimes++;
//
//            double time_endComp = pcl::getTime();
//
//            aveTime += time_endComp - time_begComp;
//
//            if (resultingMatch.size() > bestMatch.size()) {
//                bestMatch = resultingMatch;
//                this_kf = pointSearchInd[his];
//
//                wdif_height = matcher.wdif_height;
//                wdif_height2 = matcher.wdif_height2;
//                wdif_normal = matcher.wdif_normal;
//                wrel_dist_centers = matcher.wrel_dist_centers;
//                wal = matcher.wal;
//                wea = matcher.wea;
//            }
//        }
//    }
//
////    std::cout<<"!!!!!!!!!"<<std::endl;
////    std::cout<<"wdif_height "<<wdif_height<<std::endl;
////    std::cout<<"wdif_height2 "<<wdif_height2<<std::endl;
////    std::cout<<"wdif_normal "<<wdif_normal<<std::endl;
////    std::cout<<"wrel_dist_centers "<<wrel_dist_centers<<std::endl;
////    std::cout<<"!!!!!!!!!"<<std::endl;
//
//
//    std::cout<<"comp time "<<aveTime/graphmatchTimes<<std::endl;
//
//    std::vector<Eigen::Vector3f> kvc;
//    std::vector<Eigen::Vector3f> lvc;
//    std::vector<Eigen::Vector3f> kvn;
//    std::vector<Eigen::Vector3f> lvn;
//
//    for (map<unsigned, unsigned>::iterator it = bestMatch.begin(); it != bestMatch.end(); it++)
//    {
//        kvc.push_back(keyframe_vec[this_kf]->vPlanes[it->first].v3center);
//        lvc.push_back(last_keyframe->vPlanes[it->second].v3center);
//        kvn.push_back(keyframe_vec[this_kf]->vPlanes[it->first].v3normal);
//        lvn.push_back(last_keyframe->vPlanes[it->second].v3normal);
//    }
//
//    double aveTime1 = 0.0;
//    int graphmatchTimes1 = 0;
//
//    //KITTI
//    std::map<unsigned, unsigned> bestMatchVehicle; bestMatchVehicle.clear();
//    int this_kf_vehicle = 0;
//
//    if (last_keyframe->vVehicles.size() > 2) {
//
//        for (size_t his = 0; his < pointSearchInd.size(); his++) {
//            if ((keyframe_vec.size() - pointSearchInd[his]) <= 10) {
//                continue;
//            }
//
//            if (keyframe_vec[pointSearchInd[his]]->vVehicles.size() < 3)
//                continue;
//
//            Subgraph currentSubgraph(keyframe_vec[pointSearchInd[his]]->vVehicles, 0);
//            Subgraph targetSubgraph(last_keyframe->vVehicles, 0);
//
//
//            double time_begComp = pcl::getTime();
//
//            graphmatchTimes1++;
//
//
//            int unaycount;
//            std::map<unsigned, unsigned> resultingMatch = matcher.compareSubgraphsVehiclePlaneRef(currentSubgraph, targetSubgraph, unaycount, kvc,
//                                                                                                  lvc, kvn, lvn);
//
//            double time_endComp = pcl::getTime();
//
//            aveTime1 += time_endComp - time_begComp;
//
//
//            if (resultingMatch.size() > bestMatchVehicle.size()) {
//                bestMatchVehicle = resultingMatch;
//                this_kf_vehicle = pointSearchInd[his];
//            }
//        }
//    }
//
//
//    std::map<unsigned, unsigned> bestMatchPole; bestMatchPole.clear();
//    int this_kf_pole = 0;
//
//    if (last_keyframe->vPoles.size() > 2) {
//
//        for (size_t his = 0; his < pointSearchInd.size(); his++) {
//            if ((keyframe_vec.size() - pointSearchInd[his]) <= 10) {
//                continue;
//            }
//
//            if (keyframe_vec[pointSearchInd[his]]->vPoles.size() < 3)
//                continue;
//
//            Subgraph currentSubgraph(keyframe_vec[pointSearchInd[his]]->vPoles, 0);
//            Subgraph targetSubgraph(last_keyframe->vPoles, 0);
//
//
//            double time_begComp = pcl::getTime();
//
//            graphmatchTimes1++;
//
//            int unaycount;
//            std::map<unsigned, unsigned> resultingMatch = matcher.compareSubgraphsPolePlaneRef(currentSubgraph, targetSubgraph, unaycount, kvc,
//                                                                                               lvc, kvn, lvn);
//
//            double time_endComp = pcl::getTime();
//
//            aveTime1 += time_endComp - time_begComp;
//
//
//            if (resultingMatch.size() > bestMatchPole.size()) {
//                bestMatchPole = resultingMatch;
//                this_kf_pole = pointSearchInd[his];
//            }
//        }
//    }
//
//    std::cout<<"comp time 1: "<<aveTime1/graphmatchTimes1<<std::endl;
//
//
//    std::cout<<"+++++++++++++++++++++++++++++++"<<std::endl;
//    std::cout<<"this_kf "<<this_kf<<std::endl;
//    std::cout<<"this_kf_pole "<<this_kf_pole<<std::endl;
//    std::cout<<"this_kf_vehicle "<<this_kf_vehicle<<std::endl;
//    std::cout<<"=================="<<std::endl;
//    std::cout<<"bestMatch.size() "<<bestMatch.size()<<std::endl;
//    std::cout<<"bestMatchPole.size() "<<bestMatchPole.size()<<std::endl;
//    std::cout<<"bestMatchVehicle.size() "<<bestMatchVehicle.size()<<std::endl;
//    std::cout<<"-----------------------------"<<std::endl;
//
//    //KITTI
//    if (bestMatch.size() < 2)
//        return;
//
//    int allMatchedSize = bestMatch.size();
//
//    if (bestMatchVehicle.size() > 1 && abs(this_kf - this_kf_vehicle) < 2)
//    {
//        allMatchedSize += bestMatchVehicle.size();
//    }
//
//
//    if (bestMatchPole.size() > 1 && abs(this_kf - this_kf_pole) < 2)
//    {
//        allMatchedSize += bestMatchPole.size();
//    }
//
//
//
//
////    std::cout<<"comp time "<<aveTime/(pointSearchInd.size())<<std::endl;
//
//    std::cout<<"allMatchedSize "<<allMatchedSize<<std::endl;
//
//
////KITTI
//    if (allMatchedSize < 7) {
//        return;
//    }
//
//
//    double icp_score = 0.0;
//
//    double icp_score_t = 0.0;
//
//    //////////////////////////////
//    std::vector<pcl::PointCloud<pcl::PointXYZI>> v_selectedPc;
//    std::vector<Eigen::Vector3d> v_selectedNorm;
//    std::vector<Eigen::Vector3d> v_selectedNormMatch;
//
//    std::vector<double> v_d;
//
//    for (map<unsigned, unsigned>::iterator it = bestMatch.begin(); it != bestMatch.end(); it++)
//    {
//        pcl::PointCloud<pcl::PointXYZI> oriPlanePs;
//        oriPlanePs = *keyframe_vec[this_kf]->vPlanes[it->first].InplanePointCloudOriPtr;
//
//        pcl::VoxelGrid< pcl::PointXYZI > filterTmp;
//        filterTmp.setInputCloud( oriPlanePs.makeShared() );
//        filterTmp.setLeafSize( 1.0, 1.0, 1.0 );
//        filterTmp.filter( oriPlanePs );
//        v_selectedPc.push_back(oriPlanePs);
//        Eigen::Vector3d selct_n = last_keyframe->vPlanes[it->second].v3normal.cast<double>();
//        v_selectedNorm.push_back(selct_n);
//
//        Eigen::Vector3d selct_n1 = keyframe_vec[this_kf]->vPlanes[it->first].v3normal.cast<double>();
//        v_selectedNormMatch.push_back(selct_n1);
//
//        v_d.push_back(last_keyframe->vPlanes[it->second].d);
//    }
//
//    std::vector<Eigen::Vector3d> v_centriods;
//    std::vector<Eigen::Vector3d> v_centriodsMatch;
//
//    if (bestMatchVehicle.size() > 1 && abs(this_kf - this_kf_vehicle) < 2)
//    {
//        for (map<unsigned, unsigned>::iterator it = bestMatchVehicle.begin(); it != bestMatchVehicle.end(); it++)
//        {
//            Eigen::Vector3d selct_n = last_keyframe->vVehicles[it->second].v3center.cast<double>();
//            v_centriods.push_back(selct_n);
//
//            Eigen::Vector3d selct_n1 = keyframe_vec[this_kf_vehicle]->vVehicles[it->first].v3center.cast<double>();
//            v_centriodsMatch.push_back(selct_n1);
//        }
//    }
//
//
//    if (bestMatchPole.size() > 1 && abs(this_kf - this_kf_pole) < 2)
//    {
//        for (map<unsigned, unsigned>::iterator it = bestMatchPole.begin(); it != bestMatchPole.end(); it++)
//        {
//            Eigen::Vector3d selct_n = last_keyframe->vPoles[it->second].v3center.cast<double>();
//            v_centriods.push_back(selct_n);
//
//            Eigen::Vector3d selct_n1 = keyframe_vec[this_kf_pole]->vPoles[it->first].v3center.cast<double>();
//            v_centriodsMatch.push_back(selct_n1);
//
//        }
//    }
//
//    //////////////////////////////
//
//    Eigen::Quaterniond quaternion;
//    Eigen::Vector3d    trans(0,0,0);
//
//
//    double init_cost, final_cost;
//
//    ///////////////////////////////////
////    double time_begMapAlign = pcl::getTime();
////
////    if (v_selectedNorm.size() > 2)
////        scene_align.find_init_tranfrom_of_two_mappings(v_selectedNorm, v_selectedNormMatch, quaternion);
////
////    if (v_centriods.size() > 2)
////        scene_align.find_init_tranfrom_of_two_mappings2(v_centriods, v_centriodsMatch, trans);
////
////    /************/
//////    std::cout<<"====test===="<<std::endl;
//////    std::cout<<keyframe_vec[this_kf]->m_accumulated_point_cloud.size()<<"  "<<keyframe_vec[this_kf]->m_accumulated_ng_pc.size()<<std::endl;
//////    std::cout<<float(keyframe_vec[this_kf]->m_accumulated_point_cloud.size())/float(keyframe_vec[this_kf]->m_accumulated_ng_pc.size())<<std::endl;
//////
//////    scene_align.find_tranfrom_of_two_mappings(keyframe_vec[this_kf]->m_accumulated_point_cloud, last_keyframe->m_accumulated_point_cloud, icp_score_t);
//////    scene_align.find_tranfrom_of_two_mappings(keyframe_vec[this_kf]->m_accumulated_ng_pc, last_keyframe->m_accumulated_ng_pc, icp_score_t);
//////    std::cout<<"====test===="<<std::endl;
////    /************/
////
////    scene_align.find_tranfrom_of_two_mappings(keyframe_vec[this_kf]->m_accumulated_surf_pc, keyframe_vec[this_kf]->m_accumulated_line_pc,
////                                              last_keyframe->m_accumulated_surf_pc, last_keyframe->m_accumulated_line_pc,
////                                              icp_score, v_selectedPc, v_selectedNorm, v_d, quaternion, trans, init_cost, final_cost);
////
////    double time_endMapAlign = pcl::getTime();
////
////    std::cout<<"align time "<<time_endMapAlign-time_begMapAlign<<std::endl;
/////////////////////////////////
//
//    std::cout<<icp_score<<"  "<<init_cost<<"  "<<final_cost<<std::endl;
//
//    printf("ICP inlier threshold = %lf\r\n", icp_score);
//
//    auto Q_a = pose3d_vec[this_kf].q;
//    auto Q_b = pose3d_vec[pose3d_vec.size() - 1].q;
//    auto T_a = pose3d_vec[this_kf].p;
//    auto T_b = pose3d_vec[pose3d_vec.size() - 1].p;
//    auto ICP_q = scene_align.m_q_w_curr;
//    auto ICP_t = scene_align.m_t_w_curr;
//
//    ICP_t = ( ICP_q.inverse() * ( -ICP_t ) );
//    ICP_q = ICP_q.inverse();
//
//    std::cout << "ICP_q = " << ICP_q.coeffs().transpose() << std::endl;
//    std::cout << "ICP_t = " << ICP_t.transpose() << std::endl;
//
//    //KITTI
////    if ( icp_score < 0.31 )
////    if ( icp_score < 0.35 )
//
////    if ( icp_score < 0.31 && final_cost > 50.0)
//    {
//
//        v_icp.push_back(icp_score_t);
//
//        double t_s = 0.0;
//        for (auto item : v_icp)
//        {
//            t_s += item;
//        }
//
//        std::cout<<"t_s ave: "<<t_s/v_icp.size()<<std::endl;
//
//        laserCloudOri_m2.points.clear();
//        laserCloudOri_m2_1.points.clear();
//        pcl::PointCloud<pcl::PointXYZI> laserCloudOri_m2bk;
//
//        for (map<unsigned, unsigned>::iterator it = bestMatch.begin(); it != bestMatch.end(); it++)
//        {
//            laserCloudOri_m2bk = *keyframe_vec[this_kf]->vPlanes[it->first].planePointCloudPtr;
//            for (size_t ii = 0 ; ii < laserCloudOri_m2bk.points.size() ; ++ii)
//            {
//                pcl::PointXYZRGBA tp1;
//                tp1.x = laserCloudOri_m2bk.points[ii].x;
//                tp1.y = laserCloudOri_m2bk.points[ii].y;
//                tp1.z = laserCloudOri_m2bk.points[ii].z;
//                tp1.r = 255.0;
//                tp1.g = 0.0;
//                tp1.b = 0.0;
//                laserCloudOri_m2_1.points.push_back(tp1);
//            }
//
//            laserCloudOri_m2bk = *last_keyframe->vPlanes[it->second].planePointCloudPtr;
//            for (size_t ii = 0 ; ii < laserCloudOri_m2bk.points.size() ; ++ii)
//            {
//                pcl::PointXYZRGBA tp1;
//                tp1.x = laserCloudOri_m2bk.points[ii].x;
//                tp1.y = laserCloudOri_m2bk.points[ii].y;
//                tp1.z = laserCloudOri_m2bk.points[ii].z;
//                tp1.r = 255.0;
//                tp1.g = 255.0;
//                tp1.b = 0.0;
//                laserCloudOri_m2_1.points.push_back(tp1);
//            }
//
//
//            laserCloudOri_m2 += *keyframe_vec[this_kf]->vPlanes[it->first].planePointCloudPtr;
//            laserCloudOri_m2 += *last_keyframe->vPlanes[it->second].planePointCloudPtr;
//        }
//
//        for (map<unsigned, unsigned>::iterator it = bestMatchVehicle.begin(); it != bestMatchVehicle.end(); it++)
//        {
//            laserCloudOri_m2bk = *keyframe_vec[this_kf_vehicle]->vVehicles[it->first].VehiclePointCloudPtr;
//            for (size_t ii = 0 ; ii < laserCloudOri_m2bk.points.size() ; ++ii)
//            {
//                pcl::PointXYZRGBA tp1;
//                tp1.x = laserCloudOri_m2bk.points[ii].x;
//                tp1.y = laserCloudOri_m2bk.points[ii].y;
//                tp1.z = laserCloudOri_m2bk.points[ii].z;
//                tp1.r = 0.0;
//                tp1.g = 255.0;
//                tp1.b = 0.0;
//                laserCloudOri_m2_1.points.push_back(tp1);
//            }
//
//            laserCloudOri_m2bk = *last_keyframe->vVehicles[it->second].VehiclePointCloudPtr;
//            for (size_t ii = 0 ; ii < laserCloudOri_m2bk.points.size() ; ++ii)
//            {
//                pcl::PointXYZRGBA tp1;
//                tp1.x = laserCloudOri_m2bk.points[ii].x;
//                tp1.y = laserCloudOri_m2bk.points[ii].y;
//                tp1.z = laserCloudOri_m2bk.points[ii].z;
//                tp1.r = 255.0;
//                tp1.g = 255.0;
//                tp1.b = 0.0;
//                laserCloudOri_m2_1.points.push_back(tp1);
//            }
//
//
//            laserCloudOri_m2 += *keyframe_vec[this_kf_vehicle]->vVehicles[it->first].VehiclePointCloudPtr;
//            laserCloudOri_m2 += *last_keyframe->vVehicles[it->second].VehiclePointCloudPtr;
//        }
//
//        for (map<unsigned, unsigned>::iterator it = bestMatchPole.begin(); it != bestMatchPole.end(); it++)
//        {
//            laserCloudOri_m2bk = *keyframe_vec[this_kf_pole]->vPoles[it->first].PolePointCloudPtr;
//            for (size_t ii = 0 ; ii < laserCloudOri_m2bk.points.size() ; ++ii)
//
//            {
//                pcl::PointXYZRGBA tp1;
//                tp1.x = laserCloudOri_m2bk.points[ii].x;
//                tp1.y = laserCloudOri_m2bk.points[ii].y;
//                tp1.z = laserCloudOri_m2bk.points[ii].z;
//                tp1.r = 0.0;
//                tp1.g = 0.0;
//                tp1.b = 255.0;
//                laserCloudOri_m2_1.points.push_back(tp1);
//            }
//
//            laserCloudOri_m2bk = *last_keyframe->vPoles[it->second].PolePointCloudPtr;
//            for (size_t ii = 0 ; ii < laserCloudOri_m2bk.points.size() ; ++ii)
//            {
//                pcl::PointXYZRGBA tp1;
//                tp1.x = laserCloudOri_m2bk.points[ii].x;
//                tp1.y = laserCloudOri_m2bk.points[ii].y;
//                tp1.z = laserCloudOri_m2bk.points[ii].z;
//                tp1.r = 255.0;
//                tp1.g = 255.0;
//                tp1.b = 0.0;
//                laserCloudOri_m2_1.points.push_back(tp1);
//            }
//
//            laserCloudOri_m2 += *keyframe_vec[this_kf_pole]->vPoles[it->first].PolePointCloudPtr;
//            laserCloudOri_m2 += *last_keyframe->vPoles[it->second].PolePointCloudPtr;
//        }
//
////        std::cout<<"save !!"<<std::endl;
////        laserCloudOri_m2_1.width = 1;
////        laserCloudOri_m2_1.height = laserCloudOri_m2_1.points.size();
////
////        std::string pathsave = string("/home/jjwen/software/catkin_rangenet_ws/src/") +  to_string(keyFrameCount) + ".pcd";
////
////        pcl::io::savePCDFileASCII (pathsave, laserCloudOri_m2_1); //将点云保存到PCD文件中
//
//
//        std::cout<<"bestMatchVehicle.size() "<<bestMatchVehicle.size()<<std::endl;
//        std::cout<<"last_keyframe->vVehicles.size() "<<last_keyframe->vVehicles.size()<<std::endl;
//        std::cout<<"keyframe_vec[this_kf_vehicle]->vVehicles.size() "<<keyframe_vec[this_kf_vehicle]->vVehicles.size()<<std::endl;
//
//
//        printf("I believe this is true loop.\r\n");
//
//        VectorOfConstraints constrain_vec_temp;
//        constrain_vec_temp = constrain_vec;
//
//        /*闭环约束*/
//        Constraint3d pose_constrain;
//        auto q_res = Q_b.inverse() * ICP_q.inverse() * Q_a;
//        //q_res = q_res.inverse();
//        auto t_res = Q_b.inverse() * ( ICP_q.inverse() * ( T_a - ICP_t ) - T_b );
//        //t_res = q_res.inverse()*(-t_res);
//        //q_res = q_res.inverse();
//
////                cout << "=== Add_constrain_of_loop ====" << endl;
////                cout << Q_a.coeffs().transpose() << endl;
////                cout << Q_b.coeffs().transpose() << endl;
////                cout << ICP_q.coeffs().transpose() << endl;
////                cout << T_a.transpose() << endl;
////                cout << T_b.transpose() << endl;
////                cout << ICP_t.transpose() << endl;
////                cout << "Result: " << endl;
////                cout << q_res.coeffs().transpose() << endl;
////                cout << t_res.transpose() << endl;
//
//        //t_res.setZero();
//        pose_constrain.id_begin = pose3d_vec.size() - 1;
//        pose_constrain.id_end = this_kf;
//        pose_constrain.t_be.p = t_res;
//        pose_constrain.t_be.q = q_res;
//        /*闭环约束*/
//
//
//        loop_closure_matchedid[pose3d_vec.size() - 1] = this_kf;
//
//        constrain_vec_temp.push_back( pose_constrain );
//
//
//        pose3d_map_ori = pose3d_map;
//        auto temp_pose_3d_map = pose3d_map;
//
//        pose_graph_optimization(temp_pose_3d_map, constrain_vec_temp);
//
//        optimized_pose3d_map = temp_pose_3d_map;
//
//        ////////
//
////        constrain_vec = constrain_vec_temp;
////        pose3d_map = temp_pose_3d_map;
//
//        ////////
//
//        OutputPoses( std::string("/home/jjwen/result/poses_ori.txt" ), pose3d_map_ori );
//        OutputPoses( std::string( "/home/jjwen/result/poses_opm.txt" ), temp_pose_3d_map );
//
//
////        refined_pt = map_rfn.refine_pointcloud( map_id_pc, pose3d_map_ori, temp_pose_3d_map, ( int ) map_id_pc.size() - 1);
//
//        refined_pt.points.clear();
//        refined_pt_bef.points.clear();
//
//        for ( int pc_idx = ( int ) map_id_pc.size() - 1; pc_idx >= 0; pc_idx -= 2 )
//        {
////            std::cout << "*** Refine pointcloud, curren idx = " << pc_idx << " ***" << endl;
//            refined_pt += map_rfn.refine_pointcloud( map_id_pc, pose3d_map_ori, temp_pose_3d_map, pc_idx);
//
//            refined_pt_bef += map_rfn.refine_pointcloud( map_id_pc, pose3d_map_ori, pose3d_map_ori, pc_idx);
//
//
//        }
//        //map_rfn.refine_mapping( path_name, 0 );
//        if ( 0 )
//        {
//            map_rfn.refine_mapping( map_id_pc, pose3d_map_ori, temp_pose_3d_map);
////            map_rfn.m_pts_aft_refind
//        }
//
//    }
//
//}
//
//
//
//
//
//void LiPMatch::run()
//{
//    size_t numPrevKFs = 0;
//
//    while(!LiPMatch_stop)  // Stop loop if LiPMatch
//    {
//        if( numPrevKFs == frameQueue.size() )
//        {
//            sleep(10);
//        }
//        else
//        {
//            detectPlanesCloud( frameQueue[numPrevKFs], numPrevKFs);
//            ++numPrevKFs;
//        }
//    }
//    LiPMatch_finished = true;
//}
//
//
//
//bool LiPMatch::stop_LiPMatch()
//{
//    LiPMatch_stop = true;
//    while(!LiPMatch_finished)
//        sleep(1);
//
//    cout << "Waiting for LiPMatch thread to die.." << endl;
//
//    joinThread(LiPMatch_hd);
//    LiPMatch_hd.clear();
//
//    return true;
//}
//
//LiPMatch::~LiPMatch()
//{
//    cout << "\n\n\nLiPMatch destructor called -> Save color information to file\n";
//
//    stop_LiPMatch();
//
//    cout << " .. LiPMatch has died." << endl;
//}